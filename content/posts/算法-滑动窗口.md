---
title: "算法 滑动窗口"
date: 2021-06-26T01:15:43+08:00
draft: false
---

# 时间复杂度

O(n): 左右标记都最多移动 n 次



[连续子区间和](https://www.nowcoder.com/questionTerminal/c7db49124acd415f801eb67de09c6d81?f=discussion)

窗口内的元素之和，大于给定值时，则窗口右标及之后的子数组都应该算在结果中

不能统计左下标及之前的个数，因为窗口之和可能远大于给定值，之后向后滑动时，会重复统计：

数组： 2 4 7 

 和：6

[2, 2] -> 0

[2, 4] -> 1

[4, 4] -> 0

[4, 7] -> 2

[7,7] -> 3

有重复统计

```c++
#include <vector>
#include <iostream>
using namespace std;

long long f(vector<int> &v, long long sum) {
    if(v.size() == 0) {
        return 0;
    }
    
    long long res = 0;
    int l = 0; 
    int r = 0;
    long long s = v[0];
    while(l < v.size()) {
        if(s < sum) {
            if(r + 1 >= v.size()) {
                break;
            }
            r++;
            s += v[r];
            continue;
        }
        if(s >= sum) {
            res += v.size() - r;
            s -= v[l];
            l++;
        }
    }
    
    return res;
}

int main() {
    int c;
    int x;
    cin >> c >> x;
    
    vector<int> v;
    for(int i = 0; i < c; i++) {
        int k;
        cin >> k;
        v.push_back(k);
    }
    cout << f(v, x) << endl;
    return 0;
}
```

