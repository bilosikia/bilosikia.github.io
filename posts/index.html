<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link href=/posts/index.xml rel=alternate type=application/rss+xml title="bilosikia's site"><link href=/posts/index.xml rel=feed type=application/rss+xml title="bilosikia's site"><title>Posts</title><link rel=stylesheet href=https://bilosikia.github.io/css/colors-dark.min.91962b8a364d509ff3d76bb0de34f672d0f09e1485bda7795118d692ecb4e0ea.css></head><body><header id=header><h1><a href=https://bilosikia.github.io>bilosikia's site</a></h1><p></p></header><div id=page><div id=sidebar><nav></nav></div><div id=content><article class=post><h1><a href=https://bilosikia.github.io/posts/rust-pin-unpin/></a></h1><div class=post-content><p>rust Pin & Unpin 如何在 Rust 中实现一个自引用的数据结构 struct SelfRef&lt;'a> { s: String, s_ref: Option&lt;&'a mut str> } fn main() { let mut a = SelfRef { s: "hello".to_owned(), s_ref: None }; a.s_ref = Some(a.s.as_str()); println!("{:?}", a.s_ref); // 下面代码编译错误 // let b = a; // println!("{:?}", b.s_ref); } output： Some("hello") 代码能正常运行，a.s_ref 保存了一个指向 a.s 的引用。 但是当我们执行被注释的代码时，即尝试将 a 赋值给 b 时，编译器报了如下错误：
a.s_ref = Some(a.s.as_str()); | --- borrow of `a.s` occurs here move out of `a` occurs here, borrow later used here 由于 SelfRef 没有自动实现 Copy， 当执行 let b = a 时，实际发生了 move： …</p></div><p class=meta>Posted on <span class=postdate>01. January 0001</span></p></article></div><footer id=footer><p class=copyright>Powered by <a href=https://gohugo.io/>Hugo</a> and the
<a href=https://github.com/bake/solar-theme-hugo>Solar</a>-theme.</p></footer></div></body></html>