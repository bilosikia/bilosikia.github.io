<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link href=/posts/index.xml rel=alternate type=application/rss+xml title="bilosikia's site"><link href=/posts/index.xml rel=feed type=application/rss+xml title="bilosikia's site"><title>Posts</title><link rel=stylesheet href=https://bilosikia.github.io/css/colors-dark.min.91962b8a364d509ff3d76bb0de34f672d0f09e1485bda7795118d692ecb4e0ea.css></head><body><header id=header><h1><a href=https://bilosikia.github.io>bilosikia's site</a></h1><p></p></header><div id=page><div id=sidebar><nav></nav></div><div id=content><article class=post><h1><a href=https://bilosikia.github.io/posts/my-first-post/>My First Post</a></h1><div class=post-content><p>进程在 Linux 上是一个开销不小的家伙，先不说创建，光是上下文切换一次就得几个微秒。所以为了高效地对海量用户提供服务，必须要让一个进程能同时处理很多个 tcp 连接才行。现在假设一个进程保持了 10000 条连接，那么如何发现哪条连接上有数据可读了、哪条连接可写了 ？
我们当然可以采用循环遍历的方式来发现 IO 事件，但这种方式太低级了。我们希望有一种更高效的机制，在很多连接中的某条上有 IO 事件发生的时候直接快速把它找出来。其实这个事情 Linux 操作系统已经替我们都做好了，它就是我们所熟知的 IO 多路复用机制。 这里的复用指的就是对进程的复用。
在 Linux 上多路复用方案有 select、poll、epoll。 它们三个中 epoll 的性能表现是最优秀的，能支持的并发量也最大。所以我们今天把 epoll 作为要拆解的对象，深入揭秘内核是如何实现多路的 IO 管理的。
为了方便讨论，我们举一个使用了 epoll 的简单示例（只是个例子，实践中不这么写）：
int main(){ listen(lfd, &mldr;);
cfd1 = accept(...); cfd2 = accept(...); efd = epoll_create(...); epoll_ctl(efd, EPOLL_CTL_ADD, cfd1, ...); epoll_ctl(efd, EPOLL_CTL_ADD, cfd2, ...); epoll_wait(efd, ...) } 其中和 epoll 相关的函数是如下三个：
epoll_create：创建一个 epoll 对象 epoll_ctl：向 epoll 对象中添加要管理的连接 epoll_wait：等待其管理的连接上的 IO 事件 借助这个 demo，我们来展开对 epoll 原理的深度拆解。相信等你理解了这篇文章以后，你对 epoll 的驾驭能力将变得炉火纯青！！ …</p></div><p class=meta>Posted on <span class=postdate>15. April 2021</span></p></article></div><footer id=footer><p class=copyright>Powered by <a href=https://gohugo.io/>Hugo</a> and the
<a href=https://github.com/bake/solar-theme-hugo>Solar</a>-theme.</p></footer></div></body></html>