<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.110.0">
  <title> c&#43;&#43;20 coroutine | bilosikia </title>
  <link rel="stylesheet" href="https://bilosikia.github.io/css/simpleness.css">
  <link rel="canonical" href="https://bilosikia.github.io/posts/c&#43;&#43;/coroutine/">
  <link rel="alternate" type="application/rss+xml" href="" title="bilosikia">
  
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
  
</head>
<body class="container">
  <nav class="navigation">
  <div class="nav-left">
    
    <a href="https://bilosikia.github.io/">bilosikia</a>
    
    <div class="nav-item nav-title">
      <a href="https://bilosikia.github.io/"> bilosikia</a>
    </div>
    <div class="nav-item nav-menu">
      
    </div>
  </div>
  <div class="nav-item nav-right fontawesome">
    
    
    
  </div>
</nav>

  
<article class="post">
  <header class="post-header">
    <h1 style="text-align: center;" >c&#43;&#43;20 coroutine</h1>
    <div class="post-metadata">
    
      <time datetime="2022-09-11T14:55:59&#43;08:00">September 11, 2022</time> &nbsp; 
    
    
    
    
    
    
    </div>
  </header>

  
  <div class="post-toc">
    <div class="post-toc-title">Contents</div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#什么是协程">什么是协程</a></li>
    <li><a href="#协程分类">协程分类</a></li>
    <li><a href="#协程-coroutine-frame">协程 coroutine frame</a></li>
  </ul>

  <ul>
    <li><a href="#协程接口">协程接口</a></li>
    <li><a href="#co_await">co_await</a></li>
  </ul>
</nav>
  </div>
  

  <div class="post-text">
    <h1 id="协程">协程</h1>
<h2 id="什么是协程">什么是协程</h2>
<ul>
<li>可以在指定位置暂停，并从暂停点恢复执行</li>
<li>可以有多个暂停点，可以多 次返回（generator）</li>
<li>协程的本地数据需要持久化</li>
</ul>
<h2 id="协程分类">协程分类</h2>
<ul>
<li>控制传递机制: 对称/非对称（return to caller）</li>
<li>是否作为语言的第一类（first class）对象提供：语言特性和编译器支持有栈(stackfull) / 无栈(stackless): 是否有独立的运行时栈</li>
</ul>
<h2 id="协程-coroutine-frame">协程 coroutine frame</h2>
<p>协程的执行被分为 3 个阶段：</p>
<ul>
<li><strong>Suspend:</strong>  暂停当前协程的执行，返回给调用者或者恢复者</li>
<li><strong>Resume</strong>：恢复当前协程的执行</li>
<li><strong>Destroy</strong>：销毁协程栈，保持的变量，释放栈帧和内存</li>
</ul>
<p>由于协程可以被暂停，可以被恢复，协程的运行状态需要被保存下来。而栈会随着函数返回被销毁，故栈不能用来保存协程状态。</p>
<p>协程会在堆上保存自己的状态。
可以简单认为运行的协程有两部分组成：</p>
<ul>
<li>stack frame：普通的函数栈帧，会随着协作暂停而销毁，会随着协程恢复而创建。</li>
<li>coroutine frame：堆上的协程栈，会保存跨暂停点的变量，在协程暂停时，会保存暂停点用于后续恢复，保存调用的协程返回值。</li>
</ul>
<h1 id="c20-coroutinue">c++20 coroutinue</h1>
<ul>
<li>3个语言关键字，co_await, co_yield, co_return</li>
<li>一些新的类型：
<ul>
<li>coroutine_handle</li>
<li>coroutine_traits&lt;Ts…&gt;</li>
<li>suspend_always</li>
<li>suspend_never</li>
</ul>
</li>
<li>库编写者可以和协程交互以及定义行为的通用机制</li>
<li>更容易编写异步代码语言级设施</li>
</ul>
<p>c++20 没有提供协程库，只提供了用于构造协程库的基础设施，要直接使用现有的协程基础类型编写安全的异步代码还是非常不方便的。</p>
<p>函数体中一定要有 co_return，co_await，co_yield 三个关键字中一个，才算是一个协程。即便返回了 包含内部类 promise_type 的对象，也不是一个协程。不会有 init suspend 和 final suspend 点。</p>
<h2 id="协程接口">协程接口</h2>
<p>c++ 标准定义了两个接口：</p>
<ul>
<li>
<p><strong>Promise</strong> interfac：用来控制协程的行为</p>
<ul>
<li>定义协程被调用时的行为</li>
<li>定义协程返回时的行为</li>
<li>定义<code>co_await</code> or <code>co_yield</code> 表达式的行为</li>
</ul>
</li>
<li>
<p><strong>Awaitable</strong> interface：用来定义 co_await 表达式的语义</p>
<ul>
<li>是否暂停当前协程的执行</li>
<li>执行指定的逻辑使得协程在合适的时机恢复</li>
<li>如何获得协程的返回值</li>
</ul>
</li>
</ul>
<h2 id="co_await">co_await</h2>
<p>co_await 是一个一元操作符，co_await awaitable。</p>
<p>awaitable 需要满足特定的条件：</p>
<ul>
<li>
<p>Normally Awaitable：实现了 operator co_await()， 返回对象实现了 await_ready, await_suspend 和 await_resume，返回的对象被称为 awaiter。</p>
</li>
<li>
<p>Contextually Awaitable：co_await 表达式所在协程，有定义 await_transform 函数，用于将 someValue 转换为满足 Normally Awaitable 的对象。</p>
</li>
</ul>
<h1 id="promise_type">promise_type</h1>
<p>只要在函数体内使用了 co_await, co_yield和co_return 其中之一的关键字，就会触发编译器把该函数编译为协程而不是普通函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">co_await</span> promise.initial_suspend();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span>body<span style="color:#f92672">-</span>statements<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">catch</span> (...)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    promise.unhandled_exception();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>FinalSuspend:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">co_await</span> promise.final_suspend();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>promise_type 定义并控制了协程本身的行为。可以自定义协程被调用/返回时，co_await 或 co_yield 表达式的行为。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">promise_type</span> {
</span></span><span style="display:flex;"><span>    task<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> get_return_object();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unhandled_exception</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 控制协程在执行协程体代码之前是应该挂起，还是立即执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">initial_suspend</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在返回到调用者/恢复者之前协程有一个机会来运行一些额外的逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 此时协程体已退出，局部变量已析构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// resume 一个在 final_suspend 点挂起的协程行为是未定义的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">final_suspend</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// co_return 返回 void 时被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">return_void</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// co_return 返回 T 类型的值时被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">return_value</span>(T<span style="color:#f92672">&amp;</span> value);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 用来生成 co_await 操作符需要的 Awaitable 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Awaitable<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    Awaitable<span style="color:#f92672">&amp;&amp;</span> await_transform(Awaitable<span style="color:#f92672">&amp;&amp;</span> awaitable);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="coroutine_traits">coroutine_traits</h1>
<p>前面说到，promise_type 用来控制协程的行为。当定义了一个协程时，编译器如何知道该使用哪一个 promise type 呢？</p>
<p>coroutine_traits 是标准库定义的一个 trait，可以根据定义的协程参数，返回类型，得到 promise type。详见 <a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_traits">https://en.cppreference.com/w/cpp/coroutine/coroutine_traits</a>。</p>
<p>标准库的 coroutine_traits 要求协程的返回类型中需要定义 promise_type 类型。</p>
<p>我们也可以特化 coroutine_traits，从而可以实现把已有类型作为协程的返回类型。 如 <a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_traits">std::future </a>作为协程返回类型。</p>
<p>一般情况下，协程的库都会定义一个协程返回类型，如 cppcoro 定义的 <a href="https://github.com/lewissbaker/cppcoro/blob/master/include/cppcoro/task.hpp">task</a>。</p>
<h1 id="awaitable--awaiter">awaitable &amp; awaiter</h1>
<p>什么是 awaiter?</p>
<p>满足 co_await 运算符函数定义的对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Awaiter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当前协程是否 ready
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 在操作同步完成而不需要挂起的情况下，可以避免 &lt;suspend-coroutine&gt; 操作的成本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">await_ready</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回值成为 co_await 表达式的结果.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 也可以抛出异常，在这种情况下异常从 co_await 表达式中抛出.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果异常从 await_suspen 抛出，则协程会自动恢复，并且异常会从 co_await 表达式抛出而不调用 await_resume.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_resume</span>() <span style="color:#66d9ef">noexcept</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// void: 无条件地将执行转移回协程的调用者/恢复者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// bool: 允许 awaiter 对象有条件地返回并立即恢复协程, 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// false 时，可以立马恢复协程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// true 时，同 void
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// coroutine_handle: 将 coroutine_handle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    (<span style="color:#66d9ef">void</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">bool</span> <span style="color:#f92672">|</span> coroutine_handle) await_suspend(coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;</span> coroutine);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>什么是 awaitable？</p>
<p>能够支持 co_await 运算符。</p>
<p>支持 co_await 运算符的类型，不一定是直接的 awaiter 类型，只要能通过某种方式转换到 awaiter 对象，该类型就是 awaitable。
转换方式：</p>
<ol>
<li>类型定义了 operator co_await，返回类型就是 awaiter。</li>
<li>定义了到 awaiter 类型的转换。</li>
<li>所在 promise_type 定义了 await_transform，返回的类型可以得到/转换到 awaiter。</li>
</ol>
<p>转换伪代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> P, <span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) get_awaitable(P<span style="color:#f92672">&amp;</span> promise, T<span style="color:#f92672">&amp;&amp;</span> expr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (has_any_await_transform_member_v<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> promise.await_transform(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&amp;&amp;&gt;</span>(expr));
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&amp;&amp;&gt;</span>(expr);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Awaitable<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) get_awaiter(Awaitable<span style="color:#f92672">&amp;&amp;</span> awaitable)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (has_member_operator_co_await_v<span style="color:#f92672">&lt;</span>Awaitable<span style="color:#f92672">&gt;</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Awaitable<span style="color:#f92672">&amp;&amp;&gt;</span>(awaitable).<span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">co_await</span>();
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">constexpr</span> (has_non_member_operator_co_await_v<span style="color:#f92672">&lt;</span>Awaitable<span style="color:#f92672">&amp;&amp;&gt;</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">co_await</span>(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Awaitable<span style="color:#f92672">&amp;&amp;&gt;</span>(awaitable));
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Awaitable<span style="color:#f92672">&amp;&amp;&gt;</span>(awaitable);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="await-协程">await 协程</h1>
<p>一个协程可以 co_await 其他协程，这是两个不同的协程，它们的 coroutine_handle 的地址不同。</p>
<p>c++20 的协程是对称式的，不同于函数返回时，一定会回到调用者的调用栈，协程返回时，下一步该执行什么代码是由协程的实现决定的。当一个协程 ready 时，它可以唤醒等待它的协程，也可以唤醒其他和它没有关系的协程。</p>
<p>当协程被调用时，promise_type 的 initial_suspend 决定了协程是否可以立马被执行。
如果 initial_suspend 返回 true，则协程被创建了，并完成了协程 frame 的分配，后续需要通过 resume 或者 co_await 运算符来运行协程。</p>
<p>当协程运行后，遇到 co_await 时，awaiter 的 await_ready 决定了 awaiter 是否 ready。
如果没有 ready，会暂停当前协程，然后调用 awaiter 的 await_suspend。
如果 ready，则通过 awaiter 的 await_resume 获取被 co_await 协程（awaiter 所属协程）的返回值。</p>
<p>await_suspend 是 await 协程的关键。await_suspend 被调用时，当前协程(并非 awaiter 所属协程)已经被暂停了。根据 awaiter 的 await_suspend 函数返回值，可以控制当前协程被暂后，下一步将控制权移交给谁。</p>
<p>await_suspend 的入参 coroutine_handle 是当前调用栈所属协程：</p>
<ul>
<li>非 FinalAwaiter 时，协程已暂停，为协程调用方的 coroutine_handle。</li>
<li>FinalAwaiter 时，此时调用方为 FinalAwaiter 所在协程。</li>
</ul>
<p>await 表达式编译器生成的伪代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> value <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>expr<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> awaitable <span style="color:#f92672">=</span> get_awaitable(promise, <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(value)<span style="color:#f92672">&gt;</span>(value));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> awaiter <span style="color:#f92672">=</span> get_awaiter(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(awaitable)<span style="color:#f92672">&gt;</span>(awaitable));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>awaiter.await_ready()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">using</span> handle_t <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">using</span> await_suspend_result_t <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">decltype</span>(awaiter.await_suspend(handle_t<span style="color:#f92672">::</span>from_promise(p)));
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 先暂停当前协程(co_await 调用所在协程)，后调用 await_suspend.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 编译器生成一些代码来保存协程的当前状态并准备恢复.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这包括存储 &lt;resume-point&gt; 的位置，以及将当前寄存器中的值保存到协程frame.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">&lt;</span>suspend<span style="color:#f92672">-</span>coroutine<span style="color:#f92672">&gt;</span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">constexpr</span> (is_void<span style="color:#f92672">&lt;</span>await_suspend_result_t<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 无条件暂停协程，返给给调用者，恢复者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            awaiter.await_suspend(handle_t<span style="color:#f92672">::</span>from_promise(p));
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">return</span><span style="color:#f92672">-</span>to<span style="color:#f92672">-</span>caller<span style="color:#f92672">-</span>or<span style="color:#f92672">-</span>resumer<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (awaiter.await_suspend(handle_t<span style="color:#f92672">::</span>from_promise(p))) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// bool 类型，只有为 true 时，暂停协程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">return</span><span style="color:#f92672">-</span>to<span style="color:#f92672">-</span>caller<span style="color:#f92672">-</span>or<span style="color:#f92672">-</span>resumer<span style="color:#f92672">&gt;</span> 
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 执行返回的协程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">return</span><span style="color:#f92672">-</span>to<span style="color:#f92672">-</span>coroutine<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 恢复点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">&lt;</span>resume<span style="color:#f92672">-</span>point<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取操作的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> awaiter.await_resume();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>awaiter 是协程之间通信的桥梁，co_await 一个协程时，会询问协程你当前 ready 没有，如果 ready 了，那我就获取你的结果，如果没有 ready，请告诉我应该怎么办，我是应该返回上一级，还是我应该执行其他协程。c++ 协程方案没有协程的调用器，需要由库来实现，awaiter 也是调度器实现的关键。</p>
<p>注意区分 co_await 和 co_return 的区别，co_await 是等待其他协程的结果，co_return 是为当前协程返回值，但协程的返回值如果让等待的协程获取呢？还是得通过 awaiter 的 await_resume 函数。co_return 通过调用 promise_type 的 return_value 函数，将结果保存在协程对象中，co_await 时在通过 await_resume 取回。</p>
<h1 id="协程例子">协程例子</h1>
<p>调用关系：TopTask -&gt; MiddleTask -&gt; LeafTask</p>
<p>唤醒关系：LeafTask::awaiter::await_suspend -&gt;  LeafTask::FinalAwaiter::await_suspend -&gt;MiddleTask::resume -&gt; MiddleTask::FinalAwaiter::await_suspend -&gt; TopTask::resume</p>
<p>注意，唤醒之后，协程在另一个线程中运行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;experimental/coroutine&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TopTask</span> {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span> handle_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>TopTask() {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;TopTask  destructed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">promise_type</span> {
</span></span><span style="display:flex;"><span>        TopTask <span style="color:#a6e22e">get_return_object</span>() <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> handle <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;::</span>from_promise(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;TopTask handle address: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> handle.address() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> TopTask{
</span></span><span style="display:flex;"><span>                    .handle_ <span style="color:#f92672">=</span> handle
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>suspend_always initial_suspend() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> { <span style="color:#66d9ef">return</span> {}; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>suspend_never final_suspend() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> { <span style="color:#66d9ef">return</span> {}; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unhandled_exception</span>() <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">return_void</span>() <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MiddleTask</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FinalAwaiter</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">promise_type</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;</span> handle_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">promise_type</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span> continuation_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        MiddleTask <span style="color:#a6e22e">get_return_object</span>() <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> handle <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;::</span>from_promise(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MiddleTask handle address: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> handle.address() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> MiddleTask{
</span></span><span style="display:flex;"><span>                    .handle_ <span style="color:#f92672">=</span> handle
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>suspend_never initial_suspend() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> { <span style="color:#66d9ef">return</span> {}; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        FinalAwaiter <span style="color:#a6e22e">final_suspend</span>() <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> h <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;::</span>from_promise(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> {.handle_ <span style="color:#f92672">=</span> h};
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unhandled_exception</span>() <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">return_void</span>() <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FinalAwaiter</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;</span> handle_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">await_ready</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_suspend</span>(std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span> cont) <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MiddleTask FinalAwaiter await_suspend: cont address= &#34;</span> <span style="color:#f92672">&lt;&lt;</span> cont.address() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>                      <span style="color:#f92672">&lt;&lt;</span> handle_.address() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MiddleTask FinalAwaiter await_suspend, resume continuation&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            handle_.promise().continuation_.resume();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_resume</span>() <span style="color:#66d9ef">noexcept</span> {}
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Awaiter</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;</span> handle_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">await_ready</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_suspend</span>(std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span> cont) {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MiddleTask await_suspend: cont= &#34;</span> <span style="color:#f92672">&lt;&lt;</span> cont.address() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;handle= &#34;</span> <span style="color:#f92672">&lt;&lt;</span> handle_.address()
</span></span><span style="display:flex;"><span>                      <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;MiddleTask await_suspend:, do nothing, return to caller&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            handle_.promise().continuation_ <span style="color:#f92672">=</span> cont;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_resume</span>() {}
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Awaiter <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">co_await</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Awaiter{.handle_ <span style="color:#f92672">=</span> handle_};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LeafTask</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FinalAwaiter</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Awaiter</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">promise_type</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;</span> handle_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">promise_type</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span> continue_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        LeafTask <span style="color:#a6e22e">get_return_object</span>() <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> handle <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;::</span>from_promise(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;LeafTask handle address: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> handle.address() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> LeafTask{.handle_ <span style="color:#f92672">=</span> handle};
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>suspend_always initial_suspend() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> {};
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        FinalAwaiter <span style="color:#a6e22e">final_suspend</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> FinalAwaiter{};
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unhandled_exception</span>() <span style="color:#66d9ef">noexcept</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">return_void</span>() <span style="color:#66d9ef">noexcept</span> {}
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FinalAwaiter</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">await_ready</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// cont 是 FinalAwaiter 所在协程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span>        await_suspend(std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;</span> cont) <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;LeafTask FinalAwaiter await_suspend: cont= &#34;</span> <span style="color:#f92672">&lt;&lt;</span> cont.address() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;LeafTask FinalAwaiter await_suspend, resume caller&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> cont.promise();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> p.continue_;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_resume</span>() <span style="color:#66d9ef">noexcept</span> {}
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Awaiter</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 所在协程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;</span>promise_type<span style="color:#f92672">&gt;</span> handle_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">await_ready</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// cont: 调用方协程. awaiter 所在协程已经被暂停
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_suspend</span>(std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>coroutine_handle<span style="color:#f92672">&lt;&gt;</span> cont) {
</span></span><span style="display:flex;"><span>            handle_.promise().continue_ <span style="color:#f92672">=</span> cont;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;LeafTask await_suspend: con= &#34;</span> <span style="color:#f92672">&lt;&lt;</span> cont.address() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;handle &#34;</span> <span style="color:#f92672">&lt;&lt;</span> handle_.address()
</span></span><span style="display:flex;"><span>                      <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> c <span style="color:#f92672">=</span> handle_;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> f <span style="color:#f92672">=</span> [c]() <span style="color:#66d9ef">mutable</span> {
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;LeafTask await_suspend, waker thread resume coroutine after 10 s&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;LeafTask await_suspend, waker thread pid: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>seconds{<span style="color:#ae81ff">5</span>});
</span></span><span style="display:flex;"><span>                c.resume();
</span></span><span style="display:flex;"><span>            };
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span>(f).detach();
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;LeafTask await_suspend, spawn waker thread, return to caller&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">await_resume</span>() {}
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Awaiter <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">co_await</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Awaiter{.handle_ <span style="color:#f92672">=</span> handle_};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LeafTask <span style="color:#a6e22e">bar</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;befor bar&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">co_await</span> std<span style="color:#f92672">::</span>experimental<span style="color:#f92672">::</span>suspend_never{};
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;after bar, current pid: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MiddleTask <span style="color:#a6e22e">foo</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;before foo&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">co_await</span> bar();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;after foo&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TopTask <span style="color:#a6e22e">boo</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;before boo&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">co_await</span> foo();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;after boo&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    TopTask t <span style="color:#f92672">=</span> boo();
</span></span><span style="display:flex;"><span>    t.handle_.resume();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;TopTask is done: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> t.handle_.done() <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>seconds(<span style="color:#ae81ff">15</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>TopTask handle address: <span style="color:#ae81ff">0x6000038d8210</span>
</span></span><span style="display:flex;"><span>before boo
</span></span><span style="display:flex;"><span>MiddleTask handle address: <span style="color:#ae81ff">0x6000023d81c0</span>
</span></span><span style="display:flex;"><span>before foo
</span></span><span style="display:flex;"><span>LeafTask handle address: <span style="color:#ae81ff">0x6000036d9120</span>
</span></span><span style="display:flex;"><span>LeafTask await_suspend: con<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x6000023d81c0</span> handle <span style="color:#ae81ff">0x6000036d9120</span>
</span></span><span style="display:flex;"><span>LeafTask await_suspend, spawn waker <span style="color:#66d9ef">thread</span>, <span style="color:#66d9ef">return</span> to caller
</span></span><span style="display:flex;"><span>MiddleTask await_suspend: cont<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x6000038d8210</span> handle<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x6000023d81c0</span>
</span></span><span style="display:flex;"><span>MiddleTask await_suspend:, <span style="color:#66d9ef">do</span> nothing, <span style="color:#66d9ef">return</span> to caller
</span></span><span style="display:flex;"><span>TopTask is done: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>LeafTask await_suspend, waker <span style="color:#66d9ef">thread</span> resume coroutine after <span style="color:#ae81ff">10</span> s
</span></span><span style="display:flex;"><span>LeafTask await_suspend, waker <span style="color:#66d9ef">thread</span> pid: <span style="color:#ae81ff">0x16d563000</span>
</span></span><span style="display:flex;"><span>befor bar
</span></span><span style="display:flex;"><span>after bar, current pid: <span style="color:#ae81ff">0x16d563000</span>
</span></span><span style="display:flex;"><span>LeafTask FinalAwaiter await_suspend: cont<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x6000036d9120</span>
</span></span><span style="display:flex;"><span>LeafTask FinalAwaiter await_suspend, resume caller
</span></span><span style="display:flex;"><span>after foo
</span></span><span style="display:flex;"><span>MiddleTask FinalAwaiter await_suspend: cont address<span style="color:#f92672">=</span> <span style="color:#ae81ff">0x6000023d81c0</span> <span style="color:#ae81ff">0x6000023d81c0</span>
</span></span><span style="display:flex;"><span>MiddleTask FinalAwaiter await_suspend, resume continuation
</span></span><span style="display:flex;"><span>after boo
</span></span></code></pre></div><h1 id="参考资料">参考资料：</h1>
<p><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await</a> 系列文章</p>

  </div>

  <footer class="post-footer">
    

    

    
    
  </footer>
  
</article>

</body>
  


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.slim.min.js" integrity="sha256-/SIrNqv8h6QGKDuNoLGA4iret+kyesCkHGzVUUV0shc=" crossorigin="anonymous"></script>
<script>
    (function() {
        var $toc = $('#TableOfContents');
        if ($toc.length > 0) {
            var $window = $(window);

            function onScroll(){
                var currentScroll = $window.scrollTop();
                var h = $('.post-text h1, .post-text h2, .post-text h3, .post-text h4, .post-text h5, .post-text h6');
                var id = "";
                h.each(function (i, e) {
                    e = $(e);
                    if (e.offset().top - 10 <= currentScroll) {
                        id = e.attr('id');
                    }
                });
                var active = $toc.find('a.active');
                if (active.length == 1 && active.eq(0).attr('href') == '#' + id) return true;

                active.each(function (i, e) {
                    $(e).removeClass('active').siblings('ul').hide();
                });
                $toc.find('a[href="#' + id + '"]').parentsUntil('#TableOfContents').each(function (i, e) {
                    $(e).children('a').addClass('active').siblings('ul').show();
                });
            }

            $window.on('scroll', onScroll);
            $(document).ready(function() {
                $toc.find('a').parent('li').find('ul').hide();
                onScroll();
                document.getElementsByClassName('post-toc')[0].style.display = '';
            });
        }
    })();
</script>


</html>
