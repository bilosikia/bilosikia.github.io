<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on bilosikia</title>
    <link>https://bilosikia.github.io/posts/</link>
    <description>Recent content in Posts on bilosikia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 23 Nov 2021 14:55:59 +0800</lastBuildDate><atom:link href="https://bilosikia.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>async fn memory layout</title>
      <link>https://bilosikia.github.io/posts/rust/async-fn-memory-layout/</link>
      <pubDate>Tue, 23 Nov 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/posts/rust/async-fn-memory-layout/</guid>
      <description>这个问题源于 rust 的一个 issue: Async fn doubles argument size
考虑下面的代码，可能会产生一下几个问题：
  async fn 生成的对象内存如何布局？
  为什么 fut1 和 fut2 的大小不一样?
  async fn wait() {} async fn foo(arg: [u8; 10]) { wait().await; drop(arg); } fn main() { let fut1 = async { let arg = [0u8; 10]; wait().await; drop(arg); }; let fut2 = foo([0u8; 10]); println!(&amp;#34;{}, {}&amp;#34;, std::mem::size_of_val(&amp;amp;fut1), std::mem::size_of_val(&amp;amp;fut2)); } 12, 22 async fn 对象内存布局 每个 async 函数被编译器实现为一个 generator，每个 await 对应于一个 yield ，每个 yield 点需要保存当前必要的上下文用于后续恢复执行。</description>
    </item>
    
    <item>
      <title>lifetime and drop</title>
      <link>https://bilosikia.github.io/posts/rust/lifetime-and-drop/</link>
      <pubDate>Tue, 23 Nov 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/posts/rust/lifetime-and-drop/</guid>
      <description>Rust 的生命周期检查为静态检查, 并且为非词法作用域。
Rust把生命周期检查的步骤由HIR改为了MIR，以便可以降低生命周期检查的粒度，使生命周期规则从词法作用域转变成非词法作用域
let mut data = vec![1, 2, 3]; let x = &amp;amp;data[0]; println!(&amp;#34;{}&amp;#34;, x); // This is OK, x is no longer needed data.push(4); 但如果 x 实现了 Drop 会怎么样呢？
#[derive(Debug)] struct X&amp;lt;&amp;#39;a&amp;gt;(&amp;amp;&amp;#39;a i32); impl Drop for X&amp;lt;&amp;#39;_&amp;gt; { fn drop(&amp;amp;mut self) {} } let mut data = vec![1, 2, 3]; let x = X(&amp;amp;data[0]); println!(&amp;#34;{:?}&amp;#34;, x); data.push(4); // Here, the destructor is run and therefore this&amp;#39;ll fail to compile.</description>
    </item>
    
    <item>
      <title>算法 滑动窗口</title>
      <link>https://bilosikia.github.io/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
      <pubDate>Sat, 26 Jun 2021 01:15:43 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid>
      <description>时间复杂度 O(n): 左右标记都最多移动 n 次
连续子区间和
窗口内的元素之和，大于给定值时，则窗口右标及之后的子数组都应该算在结果中
不能统计左下标及之前的个数，因为窗口之和可能远大于给定值，之后向后滑动时，会重复统计：
数组： 2 4 7 和：6
[2, 2] -&amp;gt; 0
[2, 4] -&amp;gt; 1
[4, 4] -&amp;gt; 0
[4, 7] -&amp;gt; 2
[7,7] -&amp;gt; 3
有重复统计
#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std; long long f(vector&amp;lt;int&amp;gt; &amp;amp;v, long long sum) { if(v.size() == 0) { return 0; } long long res = 0; int l = 0; int r = 0; long long s = v[0]; while(l &amp;lt; v.</description>
    </item>
    
    <item>
      <title>knowledge index</title>
      <link>https://bilosikia.github.io/posts/knowledge-index/</link>
      <pubDate>Wed, 09 Jun 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/posts/knowledge-index/</guid>
      <description>Linux  再谈 slab 伙伴算法 Socket write &amp;amp; read  c++   取二进制最右非 0 位：n &amp;amp; (~(n - 1)), 但是有溢出的风险
  n &amp;amp; -n returns the rightmost 1 bit in n.
  n &amp;amp; (n - 1) 消除最右 1
  X % 2^n = X &amp;amp; (2^n - 1)，环形队列实现
  GUARDED_BY
  容器元素比较：严格弱序
  s.size() - 10 的结果是无符号
  intrusive
  COW: std::string的Copy-on-Write：不如想象中美好</description>
    </item>
    
    <item>
      <title>rust Pin &amp; Unpin</title>
      <link>https://bilosikia.github.io/posts/rust/rust-pin-unpin/</link>
      <pubDate>Fri, 30 Apr 2021 17:52:54 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/posts/rust/rust-pin-unpin/</guid>
      <description>如何在 Rust 中实现一个自引用的数据结构 struct SelfRef&amp;lt;&amp;#39;a&amp;gt; { s: String, s_ref: Option&amp;lt;&amp;amp;&amp;#39;a mut str&amp;gt; } fn main() { let mut a = SelfRef { s: &amp;#34;hello&amp;#34;.to_owned(), s_ref: None }; a.s_ref = Some(a.s.as_mut()); println!(&amp;#34;{:?}&amp;#34;, a.s_ref); // 下面代码编译错误  // let b = a;  // println!(&amp;#34;{:?}&amp;#34;, b.s_ref); } output： Some(&amp;#34;hello&amp;#34;) 代码能正常运行，a.s_ref 保存了一个指向 a.s 的引用。 但是当我们执行被注释的代码时，即尝试将 a 赋值给 b 时，编译器报了如下错误：
a.s_ref = Some(a.s.as_str()); | --- borrow of `a.s` occurs here move out of `a` occurs here, borrow later used here 由于 SelfRef 没有自动实现 Copy， 当执行 let b = a 时，实际发生了 move：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://bilosikia.github.io/posts/async-fn-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bilosikia.github.io/posts/async-fn-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F/</guid>
      <description>这个问题源于 rust 的一个 issue: Async fn doubles argument size)
考虑下面的代码，可能会产生一下几个问题：
 async fn 生成的对象内存如何布局？ 为什么 fut1 和 fut2 的大小不一样?  async fn wait() {} async fn foo(arg: [u8; 10]) { wait().await; drop(arg); } fn main() { let fut1 = async { let arg = [0u8; 10]; wait().await; drop(arg); }; let fut2 = foo([0u8; 10]); println!(&amp;#34;{}, {}&amp;#34;, std::mem::size_of_val(&amp;amp;fut1), std::mem::size_of_val(&amp;amp;fut2)); } 12, 22 async fn 对象内存布局 每个 async 函数被编译器实现为一个 generator，每个 await 对应于一个 yield ，每个 yield 点需要保存当前必要的上下文用于后续恢复执行。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://bilosikia.github.io/posts/etcd-raft/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bilosikia.github.io/posts/etcd-raft/</guid>
      <description>etcd raft </description>
    </item>
    
    <item>
      <title></title>
      <link>https://bilosikia.github.io/posts/raft/learder-%E9%80%89%E4%B8%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bilosikia.github.io/posts/raft/learder-%E9%80%89%E4%B8%BE/</guid>
      <description>learder 选举   只投票给比自己新的节点
 选举前，增加自己的 term 发起投票的节点， term 大于等于当前节点 term（第三条包含） 发起投票的节点，log 要新(Up-to-date)  log中的 term 谁大谁更新 term 号相同时，logid 越大越新 注意，比较的是当前 log 中的term，并不是current_term      一个任期只投票给一个节点
  随机超时
  被隔离的节点，term 号变得极大
 导致重新选主，影响可用性 预选举 + 其他节点同意发起重新选举的条件更严格  没有收到 Leader 的心跳，即至少有一次选举超时 Candidate 日志足够新 因此无法增加 term，重新加入集群时不会导致重新选主      转为 follower, 只要有新leader term 号至少和自己的 term 号一样大
  Election Safety Property
  疑问：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://bilosikia.github.io/posts/raft/raft-member-change/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bilosikia.github.io/posts/raft/raft-member-change/</guid>
      <description>If a single configuration change adds or removes many servers, switching the cluster directly
from the old configuration to the new configuration can be unsafe; it isn’t possible to atomically
switch all of the servers at once, so the cluster can potentially split into two independent majorities
during the transition
一次变更一个成员  when adding or removing just a single server, it is safe to switch directly to the new configuration.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://bilosikia.github.io/posts/raft/servehttpkvapi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bilosikia.github.io/posts/raft/servehttpkvapi/</guid>
      <description>serveHttpKVAPI store.proposeC -&amp;gt; raft.node.propc
 put  store.Propose  s.proposeC &amp;lt;- buf.String()  prop, ok := &amp;lt;-rc.proposeC  rc.node.Propose(context.TODO(), []byte(prop))  stepWait  n.propc &amp;lt;- pm  pm := &amp;lt;-propc:  r.Step(m)  r.step(r, m)  r.appendEntry(m.Entries&amp;hellip;) r.bcastAppend()   newPipelineHandler   h.r.Process(context.TODO(), m)   Raftnode.process   rc.node.Step(ctx, m)   n.recvc &amp;lt;- m:   r.Step(m)   n.rn.HasReady()   readyc &amp;lt;- rd:   rd := &amp;lt;-rc.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://bilosikia.github.io/posts/%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bilosikia.github.io/posts/%E5%AD%A6%E4%B9%A0/</guid>
      <description>学习 专注一件事件   体系学习，书籍优于碎片博客
  利用碎片时间，集中于一个目标，不要用碎片时间零散学习
  充分利用时间，不要让自己处于不知道做什么，不知道怎么做的状态
  实践大于一切  看再多，不如自己亲手实践 把问题转化为项目 不要想着最开始覆盖所有，从最基本的开始，逐渐演进  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://bilosikia.github.io/posts/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bilosikia.github.io/posts/%E6%AF%8F%E6%97%A5%E9%98%85%E8%AF%BB/</guid>
      <description>2021-8-25  Inline In Rust 并查集  </description>
    </item>
    
  </channel>
</rss>
