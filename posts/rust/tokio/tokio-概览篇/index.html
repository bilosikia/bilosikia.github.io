<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.92.2" />
  <title> tokio-概览篇 | bilosikia </title>
  <link rel="stylesheet" href="https://bilosikia.github.io/css/simpleness.css">
  <link rel="canonical" href="https://bilosikia.github.io/posts/rust/tokio/tokio-%E6%A6%82%E8%A7%88%E7%AF%87/">
  <link rel="alternate" type="application/rss+xml" href="" title="bilosikia">
  
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
  
</head>
<body class="container">
  <nav class="navigation">
  <div class="nav-left">
    
    <a href="https://bilosikia.github.io/">bilosikia</a>
    
    <div class="nav-item nav-title">
      <a href="https://bilosikia.github.io/"> bilosikia</a>
    </div>
    <div class="nav-item nav-menu">
      
    </div>
  </div>
  <div class="nav-item nav-right fontawesome">
    
    
    
  </div>
</nav>

  
<article class="post">
  <header class="post-header">
    <h1 style="text-align: center;" >tokio-概览篇</h1>
    <div class="post-metadata">
    
      <time datetime="2021-12-12T14:55:59&#43;08:00">December 12, 2021</time> &nbsp; 
    
    
    
    
    
    
    </div>
  </header>

  

  <div class="post-text">
    <h1 id="runtime-构成">runtime 构成</h1>
<ul>
<li>
<p>Task:</p>
<p>runtime 每 spawn 一个异步函数就会产生一个 Task。Task 是 runtime 的调度单元，每个 Task 包含需要执行的 Future 和状态信息。</p>
</li>
<li>
<p>Excutor：</p>
<p>用来执行，管理，调度 Task，包含线程池，每个线程被抽象为一个 Worker。</p>
</li>
<li>
<p>Driver:</p>
<p>Task 的执行，需要 await 的地方通常是 IO，Timer等，需要依赖外部状态的改变。当外部状态改变时，Task 需要被重新调度，Driver 用于驱动 Task 的状态变更。</p>
<p>Driver 对应传统的 Reator 模型，只是不仅仅包含 IO, 还包含 Timer，Signal 等。</p>
</li>
<li>
<p>Waker：</p>
<p>属于 Task 的一部分，用于关联 Driver 和 Exuctor。当 Driver 任务 Task 就绪可以被重新调度时，通过 Waker 唤醒任务。</p>
<p>Waker 将 Driver 和 Excutor 解耦。</p>
</li>
</ul>
<p>rust 只定义了异步运行时的接口，即 Future 和 Waker。runtime 按照定义的规范实现个组件之间的协作。</p>
<p>除了 runtime 自身，凡是可阻塞操作都需要被实现为一个 Future，如 IO read/write，sleep，mutex 等，这些基础组件的实现依赖于运行时的实现，和 runtime 强绑定。</p>
<p>tokio 提供了实现了 Future 的 IO 对象，Sockets，mutext，Channel等。</p>
<h1 id="excutor--waker--driver-的协作">Excutor , Waker,  Driver 的协作</h1>
<p>Excutor 由 thread-pool 构成，每一个执行线程对应一个 Worker。</p>
<pre tabindex="0"><code>if worker 有 Notified 的 Task {
	处理 Notified Task
} else if 是否可以从其他 worker 中 steal Task {
	steal Task 并处理
} else {
	调用 Driver 的 `park`，`park_timeout`，park 将调用 Reator poll。
    if 如果有就绪的 IO 事件 {
       	调用 Task 的 waker， 将 Task 推入执行队列，excutor 从 park 中返回，并执行 Task
    } else {
       	阻塞等待 Ready 事件
    }
}
</code></pre><p>不同于传统的 Reactor 模型，由一个单独的线程监听 Ready 事件，并分发到线程池。tokio 的所有 worker 职责是一样的，都会 poll reactor。</p>
<p>Reactor 只有在被 poll 时，才会有执行 Driver 相关代码的机会，如果 Worker 的 run queue 有足够多的 Task 待执行，即便 Driver 注册的事件 Ready，也不会立马被推入可执行队列。</p>
<p>​</p>
<p>当 Driver 被 poll 时，通过调用注册事件关联的 Waker 的 waker 函数，再通过 waker 关联的 Task，将 Task 放回执行者队列。</p>
<p>对 Driver 来说，并不需要关心如何将 Task 加入执行者队列，具体实现由 Waker 定义的虚函数实现。</p>
<p>Waker 是 Task 流转的关键点。</p>
<p>​</p>
<p>Excutor 和 Driver 之间的协作，则通过定义了 Park Trait，Park Trait 抽象了 poll 模型。Driver 实现 Park，Excutor 调用相关函数，驱动 Driver 的事件被消费。在消费的过程中，使用 Waker 封装消费细节。</p>
<h1 id="driver-的层级关系">Driver 的层级关系</h1>
<p>在 tokio 的实现中，IO，Timer，Signal 等都有自己的 Driver，不同的类型的 Driver 是否启用是可配置的。</p>
<p>从 runtime 的视角，应该只有一个 Driver，且不需要关心哪些 Driver 被启用，这导致了 tokio 的 Driver 的层级关系，最顶层的 Driver 会驱动下层的 Driver。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// runtime Driver
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Driver</span> {
    inner: <span style="color:#a6e22e">TimeDriver</span>,
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TimeDriver</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::park::either::Either<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">crate</span>::time::driver::Driver<span style="color:#f92672">&lt;</span>IoStack<span style="color:#f92672">&gt;</span>, IoStack<span style="color:#f92672">&gt;</span>;

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">IoStack</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::park::either::Either<span style="color:#f92672">&lt;</span>ProcessDriver, ParkThread<span style="color:#f92672">&gt;</span>;

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ProcessDriver</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">crate</span>::process::unix::driver::Driver;

<span style="color:#75715e">// ProcessDriver
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Driver</span> {
    park: <span style="color:#a6e22e">SignalDriver</span>,
    signal_handle: <span style="color:#a6e22e">SignalHandle</span>,
}

<span style="color:#75715e">// SignalDriver
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Driver</span> {
    <span style="color:#e6db74">/// Thread parker. The `Driver` park implementation delegates to this.
</span><span style="color:#e6db74"></span>    park: <span style="color:#a6e22e">IoDriver</span>
  	<span style="color:#f92672">..</span>.
}
</code></pre></div><p>当启用所有 featurs，建立了如下的层级关系：</p>
<pre tabindex="0"><code>- RuntimeDriver
  - TimerDriver
    - ProcessDriver
      - SignalDriver
        - IoDriver
          - Mio
</code></pre><p>当不启动 IO Driver 时，建立如下的层级关系：</p>
<pre tabindex="0"><code>// 通过条件变量实现 Driver 的 park
- RuntimeDriver
  - TimerDriver
    - ParkThread
      - Condvar
</code></pre><h1 id="驱动子-driver">驱动子 Driver</h1>
<p>worker 在没有 Task 可执行时，调用 Driver 的 park 函数（类似于 epoll_wait 的作用），当没有任何 Read Task 时，Worker 线程将被阻塞，否则将 Ready 的 Task 放入可执行队列，并开始执行 Task。</p>
<p>Driver 判断是否有 Ready Task，不仅需要考虑自身的，还需要考虑下层级的 Driver。以 Timer Driver 实现为例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// Timer Driver
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Driver</span><span style="color:#f92672">&lt;</span>P: <span style="color:#a6e22e">Park</span> <span style="color:#f92672">+</span> <span style="color:#f92672">&#39;</span>static<span style="color:#f92672">&gt;</span> {
    <span style="color:#e6db74">/// Timing backend in use.
</span><span style="color:#e6db74"></span>    time_source: <span style="color:#a6e22e">ClockTime</span>,

    <span style="color:#e6db74">/// Shared state.
</span><span style="color:#e6db74"></span>    handle: <span style="color:#a6e22e">Handle</span>,

  	<span style="color:#e6db74">/// 子层级 Driver，所有 Driver 都需要实现 Park Trait
</span><span style="color:#e6db74"></span>    <span style="color:#e6db74">/// Parker to delegate to.
</span><span style="color:#e6db74"></span>    park: <span style="color:#a6e22e">P</span>,
  	<span style="color:#f92672">..</span>.
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">park_internal</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, limit: Option<span style="color:#f92672">&lt;</span>Duration<span style="color:#f92672">&gt;</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), P::Error<span style="color:#f92672">&gt;</span> {
    <span style="color:#f92672">..</span>.
    <span style="color:#66d9ef">match</span> next_wake {
      Some(when) <span style="color:#f92672">=&gt;</span> {
        <span style="color:#f92672">..</span>.
        <span style="color:#66d9ef">if</span> duration <span style="color:#f92672">&gt;</span> Duration::from_millis(<span style="color:#ae81ff">0</span>) {
					<span style="color:#75715e">// 下一个 timer 距当前还有一定时间，对 Timer Driver 来说，是需要 park 的
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// 但子层级的 Driver 可能有 Ready。
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// 只要子层级的 Driver 有 Ready 事件，Woker将不会被阻塞。
</span><span style="color:#75715e"></span>          self.park_timeout(duration)<span style="color:#f92672">?</span>;
        } <span style="color:#66d9ef">else</span> {
          <span style="color:#75715e">// 判断是否子层级的 Driver 也有 Read 的 Task，如果有的话，加入可执行队列。
</span><span style="color:#75715e"></span>          <span style="color:#75715e">// 如果没有的话，也不阻塞，因为 Timer 有 Ready 的。
</span><span style="color:#75715e"></span>          self.park.park_timeout(Duration::from_secs(<span style="color:#ae81ff">0</span>))<span style="color:#f92672">?</span>;
        }
      }
      <span style="color:#f92672">..</span>.
    }

  	<span style="color:#75715e">// 调用 Ready Timer 的 wake 函数，加入可执行队列
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Process pending timers after waking up
</span><span style="color:#75715e"></span>    self.handle.process();

    Ok(())
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">park_timeout</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, duration: <span style="color:#a6e22e">Duration</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), P::Error<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> clock <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>self.time_source.clock;

    <span style="color:#66d9ef">if</span> clock.is_paused() {
     <span style="color:#f92672">..</span>.
    } <span style="color:#66d9ef">else</span> {
      <span style="color:#75715e">// 调用子层级 Driver 的 park，如果子 Driver 无 Ready，将 park duration 时间
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 到时最近的 Timer 将会到期
</span><span style="color:#75715e"></span>      self.park.park_timeout(duration)<span style="color:#f92672">?</span>;
    }

    Ok(())
}

</code></pre></div><p>所有的 Driver 实现都遵循一样的模式，IO Driver 的底层是 mio, 且属于最底层的 Driver，当没有任务 Ready 事件时，将阻塞在 mio 的 poll 上</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">turn</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, max_wait: Option<span style="color:#f92672">&lt;</span>Duration<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
    <span style="color:#f92672">..</span>.
    <span style="color:#75715e">// Block waiting for an event to happen, peeling out how many events
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// happened.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">match</span> self.poll.poll(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> events, max_wait) {
      Ok(_) <span style="color:#f92672">=&gt;</span> {}
      Err(<span style="color:#66d9ef">ref</span> e) <span style="color:#66d9ef">if</span> e.kind() <span style="color:#f92672">==</span> io::ErrorKind::Interrupted <span style="color:#f92672">=&gt;</span> {}
      Err(e) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e),
    }
    <span style="color:#f92672">..</span>.
    Ok(())
}
</code></pre></div>
  </div>

  <footer class="post-footer">
    

    

    
    
  </footer>
  
</article>

</body>
  



</html>
