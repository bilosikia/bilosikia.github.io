<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.91.2" />
  <title> tokio-异步基础类型 | bilosikia </title>
  <link rel="stylesheet" href="https://bilosikia.github.io/css/simpleness.css">
  <link rel="canonical" href="https://bilosikia.github.io/posts/rust/tokio/tokio-%E5%BC%82%E6%AD%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/">
  <link rel="alternate" type="application/rss+xml" href="" title="bilosikia">
  
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
  
</head>
<body class="container">
  <nav class="navigation">
  <div class="nav-left">
    
    <a href="https://bilosikia.github.io/">bilosikia</a>
    
    <div class="nav-item nav-title">
      <a href="https://bilosikia.github.io/"> bilosikia</a>
    </div>
    <div class="nav-item nav-menu">
      
    </div>
  </div>
  <div class="nav-item nav-right fontawesome">
    
    
    
  </div>
</nav>

  
<article class="post">
  <header class="post-header">
    <h1 style="text-align: center;" >tokio-异步基础类型</h1>
    <div class="post-metadata">
    
      <time datetime="2021-12-19T14:55:59&#43;08:00">December 19, 2021</time> &nbsp; 
    
    
    
    
    
    
    </div>
  </header>

  

  <div class="post-text">
    <p>为了适配 async 模型，tokio 重新实现了标准库中的 fs，net，channel 等模块，提供想对应的 async 方法。</p>
<p>本文以 TcpListener 为例，剖析 tokio 如何实现异步版本的 TcpListener，以及如何与 Reactor 整合。</p>
<h1 id="数据结构关系-自顶向下">数据结构关系-自顶向下</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TcpListener</span> {
    io: <span style="color:#a6e22e">PollEvented</span><span style="color:#f92672">&lt;</span>mio::net::TcpListener<span style="color:#f92672">&gt;</span>,
}
<span style="color:#75715e">// 表示一个与 Reactor 关联的 IO 资源
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PollEvented</span><span style="color:#f92672">&lt;</span>E: <span style="color:#a6e22e">Source</span><span style="color:#f92672">&gt;</span> {
    io: Option<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span>,
    registration: <span style="color:#a6e22e">Registration</span>,
}
<span style="color:#75715e">// 表示一个已经注册到了 Reactor Io 资源
</span><span style="color:#75715e">// handle 表示注册的 Reactor Driver handle
</span><span style="color:#75715e">// shared 表示注册的 Io 相关信息引用，可用了观测 IO 状态
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Registration</span> {
    <span style="color:#e6db74">/// Handle to the associated driver.
</span><span style="color:#e6db74"></span>    handle: <span style="color:#a6e22e">Handle</span>,

    <span style="color:#e6db74">/// Reference to state stored by the driver.
</span><span style="color:#e6db74"></span>    shared: <span style="color:#a6e22e">slab</span>::Ref<span style="color:#f92672">&lt;</span>ScheduledIo<span style="color:#f92672">&gt;</span>,
}
<span style="color:#75715e">// 注册的 IO source 信息，包括就绪 events等
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ScheduledIo</span> {
    <span style="color:#e6db74">/// Packs the resource&#39;s readiness with the resource&#39;s generation.
</span><span style="color:#e6db74"></span>    readiness: <span style="color:#a6e22e">AtomicUsize</span>,

    waiters: <span style="color:#a6e22e">Mutex</span><span style="color:#f92672">&lt;</span>Waiters<span style="color:#f92672">&gt;</span>,
}
</code></pre></div><p>PollEvented 是一个可注册到 Reactor 的 Source 通用实现。实现了 mio Source Trait 的资源都可以借助此类型实现异步版本的方法。</p>
<p>Registration 是与 Reactor 交互的关键，可通过 handle 访问 Reactor(Driver), 可通过 shared 访问自身注册的事件状态。</p>
<h1 id="accept-实现">accept 实现</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">accept</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>(TcpStream, SocketAddr)<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> (mio, addr) <span style="color:#f92672">=</span> self
    .io
    .registration()
    .async_io(Interest::READABLE, <span style="color:#f92672">||</span> self.io.accept())
    .<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    <span style="color:#66d9ef">let</span> stream <span style="color:#f92672">=</span> TcpStream::new(mio)<span style="color:#f92672">?</span>;
    Ok((stream, addr))
}

<span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">async_io</span><span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span>self, interest: <span style="color:#a6e22e">Interest</span>, <span style="color:#66d9ef">mut</span> f: <span style="color:#a6e22e">impl</span> FnMut() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">loop</span> {
        <span style="color:#66d9ef">let</span> event <span style="color:#f92672">=</span> self.readiness(interest).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

        <span style="color:#66d9ef">match</span> f() {
            Err(<span style="color:#66d9ef">ref</span> e) <span style="color:#66d9ef">if</span> e.kind() <span style="color:#f92672">==</span> io::ErrorKind::WouldBlock <span style="color:#f92672">=&gt;</span> {
                self.clear_readiness(event);
            }
            x <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> x,
        }
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">readiness_fut</span>(<span style="color:#f92672">&amp;</span>self, interest: <span style="color:#a6e22e">Interest</span>) -&gt; <span style="color:#a6e22e">Readiness</span><span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span> {
    Readiness {
        scheduled_io: <span style="color:#a6e22e">self</span>,
        state: <span style="color:#a6e22e">State</span>::Init,
        waiter: <span style="color:#a6e22e">UnsafeCell</span>::new(Waiter {
            pointers: <span style="color:#a6e22e">linked_list</span>::Pointers::new(),
            waker: None,
            is_ready: <span style="color:#a6e22e">false</span>,
            interest,
            _p: <span style="color:#a6e22e">PhantomPinned</span>,
        }),
    }
}
</code></pre></div><p>Registration 提供的 async_io 抽象了异步 io。通过传入 Interest 和 执行函数，可以搭建需要的异步方法。</p>
<p>ScheduledIo 提供的 readiness_fut 函数，返回实现了 Future 的 Readiness 结构，作为最底层的叶子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Readiness</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span> {
    scheduled_io: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">ScheduledIo</span>,

    <span style="color:#75715e">// 记录状态机的状态
</span><span style="color:#75715e"></span>    state: <span style="color:#a6e22e">State</span>,

    <span style="color:#e6db74">/// Entry in the waiter `LinkedList`.
</span><span style="color:#e6db74"></span>    waiter: <span style="color:#a6e22e">UnsafeCell</span><span style="color:#f92672">&lt;</span>Waiter<span style="color:#f92672">&gt;</span>,
}
</code></pre></div><p>那注册的事件 Ready 时，如何唤醒 Readiness Future 呢？</p>
<p>在 poll 无法返回 Ready 时，需要让 Reactor 更新 wake 函数。通过设置 Readiness.waiter 的 waker 函数，并将 waiter 加入ScheduledIo.waiters 中。而 ScheduledIo 是 Reactor 和 PollEvented 共享的，从而实现了 Reactor 中注册的 Resouce 的 waker 函数更新。</p>
<p>在这里， Readiness.waiter 代表了 await 在 readiness 上的上层 Future，即 PollEvented。对 Reactor 来说，即 waite 在相关事件上的某种东西，具体是什么 Reactor 不关心，只在 Ready 时，唤醒所有的 waiter。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
    <span style="color:#f92672">..</span>.
     <span style="color:#75715e">// Safety: called while locked
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsafe</span> {
        (<span style="color:#f92672">*</span>waiter.get()).waker <span style="color:#f92672">=</span> Some(cx.waker().clone());
    }
    <span style="color:#f92672">..</span>.
     <span style="color:#75715e">// Insert the waiter into the linked list
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// safety: pointers from `UnsafeCell` are never null.
</span><span style="color:#75715e"></span>    waiters
    .list
    .push_front(<span style="color:#66d9ef">unsafe</span> { NonNull::new_unchecked(waiter.get()) });
    <span style="color:#f92672">..</span>.
}


</code></pre></div><p>在 Reator 的实现中, Ready 事件 dispatch 实现，会遍历所有 waiter，并调用 wake 函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">dispatch</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, token: <span style="color:#a6e22e">mio</span>::Token, ready: <span style="color:#a6e22e">Ready</span>) {
    <span style="color:#f92672">..</span>.
    <span style="color:#66d9ef">let</span> io <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> resources.get(addr) {
        Some(io) <span style="color:#f92672">=&gt;</span> io,
        None <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span>,
    };
    <span style="color:#f92672">..</span>.
    io.wake(ready);
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">ScheduledIo</span>::wake0(<span style="color:#f92672">&amp;</span>self, ready: <span style="color:#a6e22e">Ready</span>, shutdown: <span style="color:#66d9ef">bool</span>) {
    <span style="color:#f92672">..</span>.
    wakers.wake_all();
    <span style="color:#f92672">..</span>.
}
</code></pre></div><p>在 Reactor dispatch 时，会通过 set_readiness 函数设置 ScheduledIo 的 readiness。在 PollEvented 第一次被唤醒时，会先检查</p>
<p>ScheduledIo.readiness, 然后才检查 Waiter 自己的 is_ready 状态。因为第一次 poll 时，ScheduledIo.readiness 就是最新的状态。</p>
<h1 id="其他异步-io-实现">其他异步 io 实现</h1>
<h2 id="fs">fs</h2>
<p>并非所有的异步版本 io 资源都需要 Reactor，比如文件系统。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">open</span>(path: <span style="color:#a6e22e">impl</span> AsRef<span style="color:#f92672">&lt;</span>Path<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>File<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> path <span style="color:#f92672">=</span> path.as_ref().to_owned();
    <span style="color:#66d9ef">let</span> std <span style="color:#f92672">=</span> asyncify(<span style="color:#f92672">||</span> StdFile::open(path)).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;

    Ok(File::from_std(std))
}

<span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">asyncify</span><span style="color:#f92672">&lt;</span>F, T<span style="color:#f92672">&gt;</span>(f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">where</span>
    F: FnOnce() -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> <span style="color:#f92672">&#39;</span>static,
    T: Send <span style="color:#f92672">+</span> <span style="color:#f92672">&#39;</span>static,
{
    <span style="color:#66d9ef">match</span> spawn_blocking(f).<span style="color:#66d9ef">await</span> {
        Ok(res) <span style="color:#f92672">=&gt;</span> res,
        Err(_) <span style="color:#f92672">=&gt;</span> Err(io::Error::new(
            io::ErrorKind::Other,
            <span style="color:#e6db74">&#34;background task failed&#34;</span>,
        )),
    }
}
</code></pre></div><p>通过 spawn_blocking 返回一个 JoinHandle，即返回了一个可以 await 的 future，实现了将 open 操作转移到了 block 线程池，但自身确实非阻塞的。</p>
<h2 id="channel">Channel</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UnboundedReceiver</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#e6db74">/// The channel receiver
</span><span style="color:#e6db74"></span>    chan: <span style="color:#a6e22e">chan</span>::Rx<span style="color:#f92672">&lt;</span>T, Semaphore<span style="color:#f92672">&gt;</span>,
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">UnboundedReceiver</span>::recv(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::future::poll_fn;

    poll_fn(<span style="color:#f92672">|</span>cx<span style="color:#f92672">|</span> self.poll_recv(cx)).<span style="color:#66d9ef">await</span>
}

<span style="color:#e6db74">/// Future for the [`poll_fn`] function.
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PollFn</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
    f: <span style="color:#a6e22e">F</span>,
}

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> Unpin <span style="color:#66d9ef">for</span> PollFn<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {}

<span style="color:#e6db74">/// Creates a new future wrapping around a function returning [`Poll`].
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll_fn</span><span style="color:#f92672">&lt;</span>T, F<span style="color:#f92672">&gt;</span>(f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">PollFn</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">where</span>
    F: FnMut(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,
{
    PollFn { f }
}
</code></pre></div><p>UnboundedReceiver 本身没有实现 Future，但是通过 poll_fn 函数，返回的 PollFn 实现了 Future。</p>
<p>UnboundedReceiver 的成员函数作为了 poll 函数的一部分。即 UnboundedReceiver 自身保存了future 的状态。</p>
<p>在 ready 时，如何通知 await 的 future 呢？</p>
<p>在往 channel push，调用 rx_waker.wake()。同时，在 recv 无法 ready 时，也会更新 waker 函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T, S<span style="color:#f92672">&gt;</span> Chan<span style="color:#f92672">&lt;</span>T, S<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send</span>(<span style="color:#f92672">&amp;</span>self, value: <span style="color:#a6e22e">T</span>) {
        <span style="color:#75715e">// Push the value
</span><span style="color:#75715e"></span>        self.tx.push(value);

        <span style="color:#75715e">// Notify the rx task
</span><span style="color:#75715e"></span>        self.rx_waker.wake();
    }
    
    <span style="color:#66d9ef">pub</span>(<span style="color:#66d9ef">crate</span>) <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">recv</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;&#39;</span>_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span> {
        <span style="color:#f92672">..</span>.
        self.inner.rx_waker.register_by_ref(cx.waker());
        <span style="color:#f92672">..</span>.
    }
}

</code></pre></div>
  </div>

  <footer class="post-footer">
    

    

    
    
  </footer>
  
</article>

</body>
  



</html>
