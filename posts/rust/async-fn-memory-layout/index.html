<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.90.1" />
  <title> async fn memory layout | bilosikia </title>
  <link rel="stylesheet" href="https://bilosikia.github.io/css/simpleness.css">
  <link rel="canonical" href="https://bilosikia.github.io/posts/rust/async-fn-memory-layout/">
  <link rel="alternate" type="application/rss+xml" href="" title="bilosikia">
  
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
  
</head>
<body class="container">
  <nav class="navigation">
  <div class="nav-left">
    
    <a href="https://bilosikia.github.io/">bilosikia</a>
    
    <div class="nav-item nav-title">
      <a href="https://bilosikia.github.io/"> bilosikia</a>
    </div>
    <div class="nav-item nav-menu">
      
    </div>
  </div>
  <div class="nav-item nav-right fontawesome">
    
    
    
  </div>
</nav>

  
<article class="post">
  <header class="post-header">
    <h1 style="text-align: center;" >async fn memory layout</h1>
    <div class="post-metadata">
    
      <time datetime="2021-11-23T14:55:59&#43;08:00">November 23, 2021</time> &nbsp; 
    
    
    
    
    
    
    </div>
  </header>

  

  <div class="post-text">
    <p>这个问题源于 rust 的一个 issue: <a href="https://github.com/rust-lang/rust/issues/62958">Async fn doubles argument size</a></p>
<p>考虑下面的代码，可能会产生一下几个问题：</p>
<ul>
<li>
<p>async fn 生成的对象内存如何布局？</p>
</li>
<li>
<p>为什么 fut1 和 fut2 的大小不一样?</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Rust" data-lang="Rust"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">wait</span>() {}

<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">foo</span>(arg: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">10</span>]) {
    wait().<span style="color:#66d9ef">await</span>;
    drop(arg);
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> fut1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> {
        <span style="color:#66d9ef">let</span> arg <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span><span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">10</span>];
        wait().<span style="color:#66d9ef">await</span>;
        drop(arg);
    };
    <span style="color:#66d9ef">let</span> fut2 <span style="color:#f92672">=</span> foo([<span style="color:#ae81ff">0</span><span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">10</span>]);
    println!(<span style="color:#e6db74">&#34;{}, {}&#34;</span>, std::mem::size_of_val(<span style="color:#f92672">&amp;</span>fut1), std::mem::size_of_val(<span style="color:#f92672">&amp;</span>fut2));
}
<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">22</span>
</code></pre></div><h2 id="async-fn-对象内存布局">async fn 对象内存布局</h2>
<p>每个 async 函数被编译器实现为一个 generator，每个 await 对应于一个 yield ，每个 yield 点需要保存当前必要的上下文用于后续恢复执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> xs <span style="color:#f92672">=</span> vec![<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> gen <span style="color:#f92672">=</span> <span style="color:#f92672">||</span> {
<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> x <span style="color:#66d9ef">in</span> xs.iter() {  <span style="color:#75715e">// iter0
</span><span style="color:#75715e"></span>        sum <span style="color:#f92672">+=</span> x;
        <span style="color:#66d9ef">yield</span> sum;  <span style="color:#75715e">// Suspend0
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">for</span> x <span style="color:#66d9ef">in</span> xs.iter().rev() {  <span style="color:#75715e">// iter1
</span><span style="color:#75715e"></span>        sum <span style="color:#f92672">-=</span> x;
        <span style="color:#66d9ef">yield</span> sum;  <span style="color:#75715e">// Suspend1
</span><span style="color:#75715e"></span>    }
};

<span style="color:#75715e">//  maybe?
</span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">SumGenerator</span> {
    Unresumed { xs: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> },
    Suspend0 { xs: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>, iter0: <span style="color:#a6e22e">Iter</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">self</span>, <span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>, sum: <span style="color:#66d9ef">i32</span> },
    Suspend1 { xs: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>, iter1: <span style="color:#a6e22e">Iter</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">self</span>, <span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span>, sum: <span style="color:#66d9ef">i32</span> },
    Returned
}
</code></pre></div><p>rust 的 enum 为 tag enum，理论上内存占用为 ：tag + 最大内存占用 variant + 对齐。</p>
<p>对 async 函数，执行到一个新的 await 点时，即转变为另一个 variant，由于 enum 复用一块内存，内存被重新布局，可能发生 move。</p>
<p>但 future 对象可能包含自引用，move 后，内存安全将不被保证。所以 async 函数的每一个 variant，都有自己的内存，也就导致了最开始的问题。</p>
<p>实际上，生成器的对象布局是编译器内部行为，一般只是以 Enum 的方式来表述状态机，在实现上，并不一定是 Enum 的方式。</p>
<h2 id="fut1-和-fut2-的区别">fut1 和 fut2 的区别</h2>
<p>async 函数生成的代码，将参数作为了 Unresumed 的一个状态值保存了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Fut1Generator</span> {
    Unresumed,
    Suspend0 { arg: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">10</span>] },
    Returned
}

<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Fut2Generator</span> {
    Unresumed { arg: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">10</span>] }, <span style="color:#75715e">// future delay 执行者， arg 最为函数参数被捕获
</span><span style="color:#75715e"></span>    Suspend0 { arg: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">10</span>] },
    Returned
}
</code></pre></div><h2 id="reference">reference</h2>
<p><a href="https://tmandry.gitlab.io/blog/posts/optimizing-await-2/">https://tmandry.gitlab.io/blog/posts/optimizing-await-2/</a></p>
<p>介绍了 rust 的一些生成器内存布局的优化，但只介绍了 local 变量的优化</p>

  </div>

  <footer class="post-footer">
    

    

    
    
  </footer>
  
</article>

</body>
  



</html>
