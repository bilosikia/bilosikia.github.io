<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.91.2" />
  <title> rust Pin &amp; Unpin | bilosikia </title>
  <link rel="stylesheet" href="https://bilosikia.github.io/css/simpleness.css">
  <link rel="canonical" href="https://bilosikia.github.io/posts/rust/rust-pin-unpin/">
  <link rel="alternate" type="application/rss+xml" href="" title="bilosikia">
  
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
  
</head>
<body class="container">
  <nav class="navigation">
  <div class="nav-left">
    
    <a href="https://bilosikia.github.io/">bilosikia</a>
    
    <div class="nav-item nav-title">
      <a href="https://bilosikia.github.io/"> bilosikia</a>
    </div>
    <div class="nav-item nav-menu">
      
    </div>
  </div>
  <div class="nav-item nav-right fontawesome">
    
    
    
  </div>
</nav>

  
<article class="post">
  <header class="post-header">
    <h1 style="text-align: center;" >rust Pin &amp; Unpin</h1>
    <div class="post-metadata">
    
      <time datetime="2021-04-30T17:52:54&#43;08:00">April 30, 2021</time> &nbsp; 
    
    
    
    
    
    
    </div>
  </header>

  

  <div class="post-text">
    <h2 id="如何在-rust-中实现一个自引用的数据结构">如何在 Rust 中实现一个自引用的数据结构</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SelfRef</span><span style="color:#f92672">&lt;&#39;</span><span style="color:#a6e22e">a</span><span style="color:#f92672">&gt;</span> {
    s: String,
    s_ref: Option<span style="color:#f92672">&lt;&amp;&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#66d9ef">mut</span> <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span>
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> a <span style="color:#f92672">=</span> SelfRef {
        s: <span style="color:#e6db74">&#34;hello&#34;</span>.to_owned(),
        s_ref: None
    };
    a.s_ref <span style="color:#f92672">=</span> Some(a.s.as_mut());
    println!(<span style="color:#e6db74">&#34;{:?}&#34;</span>, a.s_ref);
    
    <span style="color:#75715e">// 下面代码编译错误
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// let b = a;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//  println!(&#34;{:?}&#34;, b.s_ref);
</span><span style="color:#75715e"></span>}

output<span style="color:#960050;background-color:#1e0010">：</span> Some(<span style="color:#e6db74">&#34;hello&#34;</span>)
</code></pre></div><p>代码能正常运行，a.s_ref 保存了一个指向 a.s 的引用。
但是当我们执行被注释的代码时，即尝试将 a 赋值给 b 时，编译器报了如下错误：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">a.s_ref <span style="color:#f92672">=</span> Some(a.s.as_str());
   <span style="color:#f92672">|</span>                    <span style="color:#f92672">---</span> borrow of <span style="color:#960050;background-color:#1e0010">`</span>a.s<span style="color:#960050;background-color:#1e0010">`</span> occurs here
<span style="color:#66d9ef">move</span> out of <span style="color:#960050;background-color:#1e0010">`</span>a<span style="color:#960050;background-color:#1e0010">`</span> occurs here, borrow later used here
</code></pre></div><p>由于 SelfRef 没有自动实现 Copy， 当执行 let b = a 时，实际发生了 move：</p>
<ol>
<li>s_ref 引用指向的还是 move 前的地址，move 后，出现了悬空引用。</li>
<li>a.s_ref 的生命周期和 a 的生命周期一样，当移动 a 时，a.s_ref 相当于还持有 a 的引用，无法移动。</li>
<li>即便在 let b = a 之前将 a.s_ref = None，依然无法编译通过，因为 rust 的生命周期是编译时的静态检查。</li>
</ol>
<p>由此可见，通过 &amp; 方式的自引用结构，由于生命周期的检查，无法执行移动操作。</p>
<p>另外, a.s_ref 将始终持有对 a 的不可变引用（即便是 &amp;mut str ）到 a 的生命周期结束，将无法获取 a 的可变引用。无法通过 &amp;mut 的方式传递参数，也不能调用参数为 &amp;mut 的方法。</p>
<p>我们能够构造自引用的数据类型，但是不通过 unsafe，我们能执行的操作是非常有限的，大大的限制了自引用结构的使用场景。
但是稍后将看到，自引用的结构是有必要的，我们需要一种机制来保证，我们无法移动该对象，从而确保引用的完整性。</p>
<h2 id="通过原始指针实现自引用">通过原始指针实现自引用</h2>
<p>除了通过引用的方式实现自引用，还可以通过指针来实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::ptr::null;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SelfRef</span> {
    s: String,
    s_ref: <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> String
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> a <span style="color:#f92672">=</span> SelfRef {
        s: <span style="color:#e6db74">&#34;hello world&#34;</span>.to_owned(),
        s_ref: <span style="color:#a6e22e">null</span>(),
    };
    a.s_ref <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a.s;
    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> a;
    <span style="color:#66d9ef">unsafe</span> {
        println!(<span style="color:#e6db74">&#34;{:?}&#34;</span>, <span style="color:#f92672">*</span>b.s_ref); <span style="color:#75715e">// what happen
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><p>原始指针不受生命周期检查的约束，所以能够编译。在我的测试中，将会打印 &ldquo;hello world&rdquo;。
那能说明，移动是安全的吗？并不是，对 b.s_ref 的访问依然是未定义行为，依赖于编译器是怎么实现的。
由于 a 是栈变量，b.s_ref 依然指向该栈变量一个偏移地址，a 被移动后，该变量的内存或许并没有被重写（性能？），导致看上去能正常运行。</p>
<p>指向自己的指针，在移动时，编译器并不会直接报错，需要一种方式来确保对象无法被移动。</p>
<h2 id="rust-中的move">Rust 中的move</h2>
<ul>
<li>Rust 中所有类型都是可以 move 的，包括 Pin 本身。</li>
<li>一些指针类型可以替换或者移动背后所指的对象：
<ul>
<li>&amp;mut T 通过 std::mem::swap 可以交换所指的对象</li>
<li>&amp;mut T 可以通过 std::mem::replace 替换所指对象</li>
<li>Box<!-- raw HTML omitted --> 可以被转换为 &amp;mut T</li>
<li>Box<!-- raw HTML omitted --> 可以通过 Deref 移动包含的对象</li>
</ul>
</li>
</ul>
<h2 id="异步代码中的自引用">异步代码中的自引用</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-RUST" data-lang="RUST"><span style="color:#66d9ef">async</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> x <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">128</span>];
    <span style="color:#66d9ef">let</span> read_into_buf_fut <span style="color:#f92672">=</span> read_into_buf(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> x);
    read_into_buf_fut.<span style="color:#66d9ef">await</span>;
    println!(<span style="color:#e6db74">&#34;{:?}&#34;</span>, x);
}
</code></pre></div><p>async 代码将被编译器翻译成一个实现了Future的结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-RUST" data-lang="RUST"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AsyncFuture</span> {
    x: [<span style="color:#66d9ef">u8</span>; <span style="color:#ae81ff">128</span>],
    read_into_buf_fut: <span style="color:#a6e22e">ReadIntoBuf</span>
    state: <span style="color:#a6e22e">State</span>,
}

<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">State</span> { 
    Start, 
    AwaitingReadIntoBuf, 
    Done
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ReadIntoBuf</span> {
    buf: <span style="color:#66d9ef">&amp;</span><span style="color:#f92672">&#39;</span><span style="color:#a6e22e">a</span> <span style="color:#a6e22e">mut</span> [<span style="color:#66d9ef">u8</span>] <span style="color:#75715e">// 可能被实现为原始指针，这儿只是为了方便描述
</span><span style="color:#75715e"></span>}
</code></pre></div><p>如果有跨 await 的变量，该变量将在子 future 中被引用，即发生了自引用。
为了防止该 future 对象被 runtime poll 时发生移动，使用了 Pin。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-RUST" data-lang="RUST"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Future {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>;
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span>;
}
</code></pre></div><h2 id="pin--unpin">Pin &amp; Unpin</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-RUST" data-lang="RUST"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
    pointer: <span style="color:#a6e22e">P</span>,
}

<span style="color:#66d9ef">pub</span> auto <span style="color:#66d9ef">trait</span> Unpin {}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PhantomPinned</span>;
<span style="color:#66d9ef">impl</span> <span style="color:#f92672">!</span>Unpin <span style="color:#66d9ef">for</span> PhantomPinned {}
</code></pre></div><ul>
<li>Pin&lt;P<!-- raw HTML omitted -->&gt; 是一个 struct 类型，保存一个指针，能确保指针所指对象T，无法被移动, 即无法直接获取保存的指针，除非 unsafe。</li>
<li>Unpin 是一个自动 Trait，实现了该 Trait 的对象，即便被包装成 Pin&lt;P<!-- raw HTML omitted -->&gt;，也能安全的被移动。即实现 Unpin Trait 的类型，不受Pin 的约束, 可以直接获得Pin包含的指针，包括 &amp;mut T，Box<!-- raw HTML omitted --> 等。</li>
<li>编译器默认所有类型都是可以移动的，即默认为所有类型实现 Unpin。</li>
<li>!Unpin 对 Unpin 取反，!Unpin 的双重否定就是 pin， 表明该类型不能随便移动。注意， !是一个操作符, 类似的还有?。</li>
<li>PhantomPinned 是一个 marker 类型，没有实现 Unpin, 用于取消编译器默认为类型实现 Unpin。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// SelfReferential 不现实Unpin
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SelfReferential</span> {
    self_ptr: <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> Self,
    _pin: <span style="color:#a6e22e">PhantomPinned</span>,
}
</code></pre></div><h2 id="pin-的实现原理">Pin 的实现原理</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-RUST" data-lang="RUST"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>P: <span style="color:#a6e22e">Deref</span><span style="color:#f92672">&gt;</span> Deref <span style="color:#66d9ef">for</span> Pin<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Target</span> <span style="color:#f92672">=</span> P::Target;
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">P</span>::Target {
        Pin::get_ref(Pin::as_ref(self))
    }
}

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>P: <span style="color:#a6e22e">DerefMut</span><span style="color:#f92672">&lt;</span>Target: Unpin<span style="color:#f92672">&gt;&gt;</span> DerefMut <span style="color:#66d9ef">for</span> Pin<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deref_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> P::Target {
        Pin::get_mut(Pin::as_mut(self))
    }
}
</code></pre></div><ul>
<li>Pin 实现了 Deref, 即所有类型都可以获得不可变引用。</li>
<li>但只为 Target 为 Unpin 的类型实现了 DerefMut，即没有实现 Unpin 的类型不可用直接获得可变引用，也就无法移动该对象了。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-RUST" data-lang="RUST"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>P: <span style="color:#a6e22e">Deref</span><span style="color:#f92672">&lt;</span>Target: Unpin<span style="color:#f92672">&gt;&gt;</span> Pin<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(pointer: <span style="color:#a6e22e">P</span>) -&gt; <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">unsafe</span> { Pin::new_unchecked(pointer) }
    }

    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">into_inner</span>(pin: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">P</span> {
        pin.pointer
    }
}

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>P: <span style="color:#a6e22e">Deref</span><span style="color:#f92672">&gt;</span> Pin<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_ref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span>P::Target<span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">unsafe</span> { Pin::new_unchecked(<span style="color:#f92672">&amp;*</span>self.pointer) }
    }
    
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new_unchecked</span>(pointer: <span style="color:#a6e22e">P</span>) -&gt; <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
        Pin { pointer }
    }

    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">into_inner_unchecked</span>(pin: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">P</span> {
        pin.pointer
    }
}
</code></pre></div><ul>
<li>into_inner，实现 Unpin 的类型，由于是可以安全的 move 的，所有可以直接获取到内部指针。</li>
<li>into_inner_unchecked，没有实现 Unpin 的类型，获得内部指针是 unsafe 的。 如 P 是 &amp;mut, 需要避免在 unsafe 代码中调用 swap 和 replace。</li>
<li>new_unchecked，没有实现 Unpin 的类型，通过该方法创建 Pin 是 unsafe 的，因为创建时，没有办法保证该指针所指的对象是没有被移动的，即需要用户保证数据是有效的。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-RUST" data-lang="RUST"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>P: <span style="color:#a6e22e">DerefMut</span><span style="color:#f92672">&gt;</span> Pin<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> P::Target<span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">unsafe</span> { Pin::new_unchecked(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> <span style="color:#f92672">*</span>self.pointer) }
    }

    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">set</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, value: <span style="color:#a6e22e">P</span>::Target)
    <span style="color:#66d9ef">where</span> P::Target: Sized {
        <span style="color:#f92672">*</span>(self.pointer) <span style="color:#f92672">=</span> value;
    }
}
</code></pre></div><ul>
<li>提供了修改 Pin 所指对象值的方法，被指向的对象可以直接给覆盖，但是依然无法移动该对象。</li>
</ul>
<h2 id="参考">参考：</h2>
<ul>
<li><a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html">Pinning - Asynchronous Programming in Rust</a></li>
<li><a href="https://doc.rust-lang.org/std/pin/index.html">https://doc.rust-lang.org/std/pin/index.html</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/n0vajw/why_the_selfreference_struct_need_pin/">https://www.reddit.com/r/rust/comments/n0vajw/why_the_selfreference_struct_need_pin/</a>（自己提问）</li>
</ul>

  </div>

  <footer class="post-footer">
    

    

    
    
  </footer>
  
</article>

</body>
  



</html>
