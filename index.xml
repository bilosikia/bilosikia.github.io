<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bilosikia</title>
    <link>https://bilosikia.github.io/</link>
    <description>Recent content on bilosikia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 26 Jun 2021 01:15:43 +0800</lastBuildDate><atom:link href="https://bilosikia.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>算法 滑动窗口</title>
      <link>https://bilosikia.github.io/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
      <pubDate>Sat, 26 Jun 2021 01:15:43 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/posts/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid>
      <description>时间复杂度 O(n): 左右标记都最多移动 n 次
连续子区间和
窗口内的元素之和，大于给定值时，则窗口右标及之后的子数组都应该算在结果中
不能统计左下标及之前的个数，因为窗口之和可能远大于给定值，之后向后滑动时，会重复统计：
数组： 2 4 7 和：6
[2, 2] -&amp;gt; 0
[2, 4] -&amp;gt; 1
[4, 4] -&amp;gt; 0
[4, 7] -&amp;gt; 2
[7,7] -&amp;gt; 3
有重复统计
#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std; long long f(vector&amp;lt;int&amp;gt; &amp;amp;v, long long sum) { if(v.size() == 0) { return 0; } long long res = 0; int l = 0; int r = 0; long long s = v[0]; while(l &amp;lt; v.</description>
    </item>
    
    <item>
      <title>知识索引</title>
      <link>https://bilosikia.github.io/posts/knowledge-index/</link>
      <pubDate>Wed, 09 Jun 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/posts/knowledge-index/</guid>
      <description>Linux  再谈 slab 伙伴算法 Socket write &amp;amp; read  c++   取二进制最右非 0 位：n &amp;amp; (~(n - 1)), 但是有溢出的风险
  GUARDED_BY
  容器元素比较：严格弱序
  s.size() - 10 的结果是无符号
  COW: std::string的Copy-on-Write：不如想象中美好
  伪共享（false sharing），并发编程无声的性能杀手
  17 版本后，可以直接写 std::array vec = {&amp;ldquo;hello&amp;rdquo;}, 不用写类型和个数了
  对 cast 完的指针就行 dereference 是 UB(TBAA 优化)
![image-20210720164420645](/Users/gaokuilin/Library/Application Support/typora-user-images/image-20210720164420645.png)
  template  测试类型 测试满足条件 static_assert 不能直接写 false  Rust   dyn Trait and impl Trait in Rust</description>
    </item>
    
    <item>
      <title>rust Pin &amp; Unpin</title>
      <link>https://bilosikia.github.io/posts/rust-pin-unpin/</link>
      <pubDate>Fri, 30 Apr 2021 17:52:54 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/posts/rust-pin-unpin/</guid>
      <description>如何在 Rust 中实现一个自引用的数据结构 struct SelfRef&amp;lt;&amp;#39;a&amp;gt; { s: String, s_ref: Option&amp;lt;&amp;amp;&amp;#39;a mut str&amp;gt; } fn main() { let mut a = SelfRef { s: &amp;#34;hello&amp;#34;.to_owned(), s_ref: None }; a.s_ref = Some(a.s.as_mut()); println!(&amp;#34;{:?}&amp;#34;, a.s_ref); // 下面代码编译错误  // let b = a;  // println!(&amp;#34;{:?}&amp;#34;, b.s_ref); } output： Some(&amp;#34;hello&amp;#34;) 代码能正常运行，a.s_ref 保存了一个指向 a.s 的引用。 但是当我们执行被注释的代码时，即尝试将 a 赋值给 b 时，编译器报了如下错误：
a.s_ref = Some(a.s.as_str()); | --- borrow of `a.s` occurs here move out of `a` occurs here, borrow later used here 由于 SelfRef 没有自动实现 Copy， 当执行 let b = a 时，实际发生了 move：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://bilosikia.github.io/posts/learder-%E9%80%89%E4%B8%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bilosikia.github.io/posts/learder-%E9%80%89%E4%B8%BE/</guid>
      <description>learder 选举   只投票给比自己新的节点
 选举前，增加自己的 term 发起投票的节点， term 大于等于当前节点 term（第三条包含） 发起投票的节点，log 要新(Up-to-date)  log中的 term 谁大谁更新 term 号相同时，logid 越大越新 注意，比较的是当前 log 中的term，并不是current_term      一个任期只投票给一个节点
  随机超时
  被隔离的节点，term 号变得极大
 导致重新选主，影响可用性 预选举 + 其他节点同意发起重新选举的条件更严格  没有收到 Leader 的心跳，即至少有一次选举超时 Candidate 日志足够新 因此无法增加 term，重新加入集群时不会导致重新选主      转为 follower, 只要有新leader term 号至少和自己的 term 号一样大
  Election Safety Property
  疑问：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://bilosikia.github.io/posts/raft-member-change/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bilosikia.github.io/posts/raft-member-change/</guid>
      <description>If a single configuration change adds or removes many servers, switching the cluster directly
from the old configuration to the new configuration can be unsafe; it isn’t possible to atomically
switch all of the servers at once, so the cluster can potentially split into two independent majorities
during the transition
一次变更一个成员  when adding or removing just a single server, it is safe to switch directly to the new configuration.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://bilosikia.github.io/posts/%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bilosikia.github.io/posts/%E5%AD%A6%E4%B9%A0/</guid>
      <description>学习 专注一件事件   体系学习，书籍优于碎片博客
  利用碎片时间，集中于一个目标，不要用碎片时间零散学习
  充分利用时间，不要让自己处于不知道做什么，不知道怎么做的状态
  实践大于一切  看再多，不如自己亲手实践 把问题转化为项目 不要想着最开始覆盖所有，从最基本的开始，逐渐演进  </description>
    </item>
    
  </channel>
</rss>
