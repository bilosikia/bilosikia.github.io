<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bilosikia's site</title><link>https://bilosikia.github.io/</link><description>Recent content on bilosikia's site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 15 Apr 2021 22:51:37 +0800</lastBuildDate><atom:link href="https://bilosikia.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>My First Post</title><link>https://bilosikia.github.io/posts/my-first-post/</link><pubDate>Thu, 15 Apr 2021 22:51:37 +0800</pubDate><guid>https://bilosikia.github.io/posts/my-first-post/</guid><description>进程在 Linux 上是一个开销不小的家伙，先不说创建，光是上下文切换一次就得几个微秒。所以为了高效地对海量用户提供服务，必须要让一个进程能同时处理很多个 tcp 连接才行。现在假设一个进程保持了 10000 条连接，那么如何发现哪条连接上有数据可读了、哪条连接可写了 ？
我们当然可以采用循环遍历的方式来发现 IO 事件，但这种方式太低级了。我们希望有一种更高效的机制，在很多连接中的某条上有 IO 事件发生的时候直接快速把它找出来。其实这个事情 Linux 操作系统已经替我们都做好了，它就是我们所熟知的 IO 多路复用机制。 这里的复用指的就是对进程的复用。
在 Linux 上多路复用方案有 select、poll、epoll。 它们三个中 epoll 的性能表现是最优秀的，能支持的并发量也最大。所以我们今天把 epoll 作为要拆解的对象，深入揭秘内核是如何实现多路的 IO 管理的。
为了方便讨论，我们举一个使用了 epoll 的简单示例（只是个例子，实践中不这么写）：
int main(){ listen(lfd, &amp;hellip;);
cfd1 = accept(...); cfd2 = accept(...); efd = epoll_create(...); epoll_ctl(efd, EPOLL_CTL_ADD, cfd1, ...); epoll_ctl(efd, EPOLL_CTL_ADD, cfd2, ...); epoll_wait(efd, ...) } 其中和 epoll 相关的函数是如下三个：
epoll_create：创建一个 epoll 对象 epoll_ctl：向 epoll 对象中添加要管理的连接 epoll_wait：等待其管理的连接上的 IO 事件 借助这个 demo，我们来展开对 epoll 原理的深度拆解。相信等你理解了这篇文章以后，你对 epoll 的驾驭能力将变得炉火纯青！！</description></item></channel></rss>