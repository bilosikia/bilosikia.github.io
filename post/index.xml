<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on bilosikia</title>
    <link>https://bilosikia.github.io/post/</link>
    <description>Recent content in Posts on bilosikia</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 25 Feb 2023 18:23:59 +0800</lastBuildDate><atom:link href="https://bilosikia.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mimalloc 实现分析</title>
      <link>https://bilosikia.github.io/post/c&#43;&#43;/mimalloc/</link>
      <pubDate>Sat, 25 Feb 2023 18:23:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/c&#43;&#43;/mimalloc/</guid>
      <description>内存管理 Allocator 主要解决的问题包括： 高性能的内存分配 避免内存碎片化，包括内部碎片和外部碎片 Slab 系统用来实现对象缓存池 安全性保障 统计分析能力 高性能的内</description>
    </item>
    
    <item>
      <title>rust Pin Project</title>
      <link>https://bilosikia.github.io/post/rust/rust-pin-project/</link>
      <pubDate>Thu, 29 Dec 2022 17:52:54 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/rust/rust-pin-project/</guid>
      <description>再谈 pin 语义 在之前，我一直以为 pin 的作用仅仅是通过无法从 Pin&amp;lt;P&amp;gt; 获得类似 &amp;amp;mut T的指针，从而能确保 T 不会 move。 一旦 Pin&amp;lt;P&amp;gt; 离开作用域被 drop 时，T 就不在受 Pin 的约</description>
    </item>
    
    <item>
      <title>c&#43;&#43;20 coroutine</title>
      <link>https://bilosikia.github.io/post/c&#43;&#43;/coroutine/</link>
      <pubDate>Sun, 11 Sep 2022 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/c&#43;&#43;/coroutine/</guid>
      <description>协程 什么是协程 可以在指定位置暂停，并从暂停点恢复执行 可以有多个暂停点，可以多 次返回（generator） 协程的本地数据需要持久化 协程分类 控制</description>
    </item>
    
    <item>
      <title>协变&amp;逆变</title>
      <link>https://bilosikia.github.io/post/rust/%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98/</link>
      <pubDate>Sun, 26 Dec 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/rust/%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98/</guid>
      <description>&amp;amp;mutT invariance 1 2 3 4 5 6 7 8 9 10 11 12 13 fn evil_feeder&amp;lt;T&amp;gt;(input: &amp;amp;mut T, val: T) { *input = val; } fn main() { let mut mr_snuggles: &amp;amp;&amp;#39;static str = &amp;#34;meow! :3&amp;#34;; // mr. snuggles forever!! { let spike = String::from(&amp;#34;bark! &amp;gt;:V&amp;#34;); let spike_str: &amp;amp;str = &amp;amp;spike; // Only lives for the block evil_feeder(&amp;amp;mut mr_snuggles, spike_str); // EVIL! } println!(&amp;#34;{}&amp;#34;, mr_snuggles); // Use after free?</description>
    </item>
    
    <item>
      <title>tokio-异步基础类型</title>
      <link>https://bilosikia.github.io/post/rust/tokio/tokio-%E5%BC%82%E6%AD%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 19 Dec 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/rust/tokio/tokio-%E5%BC%82%E6%AD%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</guid>
      <description>为了适配 async 模型，tokio 重新实现了标准库中的 fs，net，channel 等模块，提供想对应的 async 方法。 本文以 TcpListener 为例，剖析 tokio 如何实现异步版本的</description>
    </item>
    
    <item>
      <title>tokio-概览篇</title>
      <link>https://bilosikia.github.io/post/rust/tokio/tokio-%E6%A6%82%E8%A7%88%E7%AF%87/</link>
      <pubDate>Sun, 12 Dec 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/rust/tokio/tokio-%E6%A6%82%E8%A7%88%E7%AF%87/</guid>
      <description>runtime 构成 Task: runtime 每 spawn 一个异步函数就会产生一个 Task。Task 是 runtime 的调度单元，每个 Task 包含需要执行的 Future 和状态信息。 Excutor： 用来执行，管理，调</description>
    </item>
    
    <item>
      <title>async fn memory layout</title>
      <link>https://bilosikia.github.io/post/rust/async-fn-memory-layout/</link>
      <pubDate>Tue, 23 Nov 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/rust/async-fn-memory-layout/</guid>
      <description>这个问题源于 rust 的一个 issue: Async fn doubles argument size 考虑下面的代码，可能会产生一下几个问题： async fn 生成的对象内存如何布局？ 为什么 fut1 和 fut2 的大小不一样? 1 2 3 4 5 6 7</description>
    </item>
    
    <item>
      <title>lifetime 小问</title>
      <link>https://bilosikia.github.io/post/rust/lifetime-%E5%B0%8F%E9%97%AE/</link>
      <pubDate>Tue, 23 Nov 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/rust/lifetime-%E5%B0%8F%E9%97%AE/</guid>
      <description>非词法作用域 Rust 的生命周期检查为静态检查, 并且为非词法作用域。 Rust把生命周期检查的步骤由HIR改为了MIR，以便可以降低生命周期检查的粒度</description>
    </item>
    
    <item>
      <title>算法 滑动窗口</title>
      <link>https://bilosikia.github.io/post/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
      <pubDate>Sat, 26 Jun 2021 01:15:43 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</guid>
      <description>时间复杂度 O(n): 左右标记都最多移动 n 次 连续子区间和 窗口内的元素之和，大于给定值时，则窗口右标及之后的子数组都应该算在结果中 不能统计左下标及之前的</description>
    </item>
    
    <item>
      <title>keep-alive</title>
      <link>https://bilosikia.github.io/post/net/keep-alive/</link>
      <pubDate>Wed, 09 Jun 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/net/keep-alive/</guid>
      <description>keep-alive 作用： 避免无效的资源占用。如对方挂掉，NAT 等踢掉了连接等 原理： 发送探测包，SEG.SEQ = SND.NXT-1，而 SND.NXT = RCV.NXT，即发</description>
    </item>
    
    <item>
      <title>knowledge index</title>
      <link>https://bilosikia.github.io/post/knowledge-index/</link>
      <pubDate>Wed, 09 Jun 2021 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/knowledge-index/</guid>
      <description>Linux 再谈 slab 伙伴算法 Socket write &amp;amp; read seq锁 惊群效应 BBR cache c++ 取二进制最右非 0 位：n &amp;amp; (~(n - 1)), 但是有溢出的风险 n &amp;amp; -n returns the rightmost 1 bit in n. n &amp;amp; (n - 1) 消除最右 1 X % 2^n =</description>
    </item>
    
    <item>
      <title>rust Pin &amp; Unpin</title>
      <link>https://bilosikia.github.io/post/rust/rust-pin-unpin/</link>
      <pubDate>Fri, 30 Apr 2021 17:52:54 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/rust/rust-pin-unpin/</guid>
      <description>如何在 Rust 中实现一个自引用的数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct SelfRef&amp;lt;&amp;#39;a&amp;gt; { s: String, s_ref: Option&amp;lt;&amp;amp;&amp;#39;a mut str&amp;gt; } fn main() { let mut a = SelfRef { s: &amp;#34;hello&amp;#34;.to_owned(), s_ref: None }; a.s_ref = Some(a.s.as_mut()); println!(&amp;#34;{:?}&amp;#34;, a.s_ref); // 下面代码</description>
    </item>
    
    <item>
      <title>InnoDB 锁</title>
      <link>https://bilosikia.github.io/post/db/innodb-%E9%94%81/</link>
      <pubDate>Sat, 16 Nov 2019 14:55:59 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/db/innodb-%E9%94%81/</guid>
      <description>事务隔离级别 READ UNCOMMITTED 脏读。 READ COMMITTED Phantom Problem。在同一事务下，连续执行两次同样的SqL语句可能有不同的结果。 REPEATABLE READ (默认) 逻辑意义上的更新丢失问题</description>
    </item>
    
    <item>
      <title>Lock-Free简介</title>
      <link>https://bilosikia.github.io/post/c&#43;&#43;/lock-free%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 21 Sep 2019 01:15:43 +0800</pubDate>
      
      <guid>https://bilosikia.github.io/post/c&#43;&#43;/lock-free%E7%AE%80%E4%BB%8B/</guid>
      <description>基本概念 Wait-freedom: Wait-freedom means that each thread moves forward regardless of external factors like contention from other threads, other thread blocking. Each operations is executed in a bounded number of steps. It&amp;rsquo;s the strongest guarantee for synchronization algorithms. Lock-freedom: Lock-freedom means that a system as a whole moves forward regardless of anything. Forward progress for each individual thread is not guaranteed (that is, individual threads can starve).</description>
    </item>
    
  </channel>
</rss>
