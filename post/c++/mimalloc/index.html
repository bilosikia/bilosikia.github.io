<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>mimalloc 实现分析 - bilosikia</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="bilosikia" /><meta name="description" content="内存管理 Allocator 主要解决的问题包括： 高性能的内存分配 避免内存碎片化，包括内部碎片和外部碎片 Slab 系统用来实现对象缓存池 安全性保障 统计分析能力 高性能的内" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.110.0 with theme even" />


<link rel="canonical" href="https://bilosikia.github.io/post/c&#43;&#43;/mimalloc/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="mimalloc 实现分析" />
<meta property="og:description" content="内存管理 Allocator 主要解决的问题包括： 高性能的内存分配 避免内存碎片化，包括内部碎片和外部碎片 Slab 系统用来实现对象缓存池 安全性保障 统计分析能力 高性能的内" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bilosikia.github.io/post/c&#43;&#43;/mimalloc/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-02-25T18:23:59+08:00" />
<meta property="article:modified_time" content="2023-02-25T18:23:59+08:00" />
<meta itemprop="name" content="mimalloc 实现分析">
<meta itemprop="description" content="内存管理 Allocator 主要解决的问题包括： 高性能的内存分配 避免内存碎片化，包括内部碎片和外部碎片 Slab 系统用来实现对象缓存池 安全性保障 统计分析能力 高性能的内"><meta itemprop="datePublished" content="2023-02-25T18:23:59+08:00" />
<meta itemprop="dateModified" content="2023-02-25T18:23:59+08:00" />
<meta itemprop="wordCount" content="13806">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="mimalloc 实现分析"/>
<meta name="twitter:description" content="内存管理 Allocator 主要解决的问题包括： 高性能的内存分配 避免内存碎片化，包括内部碎片和外部碎片 Slab 系统用来实现对象缓存池 安全性保障 统计分析能力 高性能的内"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">bilosikia</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">bilosikia</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">mimalloc 实现分析</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-02-25 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#内存管理">内存管理</a></li>
    <li><a href="#mimalloc-原理概述">Mimalloc 原理概述</a></li>
    <li><a href="#主要数据结构">主要数据结构</a>
      <ul>
        <li><a href="#heap">Heap</a></li>
        <li><a href="#segment">Segment</a></li>
        <li><a href="#page">Page</a></li>
        <li><a href="#tld">TLD</a></li>
        <li><a href="#segment-bit-mask">Segment bit mask</a></li>
        <li><a href="#主要链表">主要链表</a></li>
        <li><a href="#主要-map">主要 map</a></li>
      </ul>
    </li>
    <li><a href="#内存分配">内存分配</a>
      <ul>
        <li><a href="#fast-path">Fast path</a></li>
        <li><a href="#slow-path">Slow path</a></li>
        <li><a href="#huge">Huge</a></li>
        <li><a href="#查找-free-page">查找 Free Page</a></li>
      </ul>
    </li>
    <li><a href="#内存-free">内存 free</a>
      <ul>
        <li><a href="#defer-free">Defer free</a></li>
        <li><a href="#heap-delayed-free">Heap delayed free</a></li>
        <li><a href="#regular-free">Regular free</a></li>
        <li><a href="#page-free">Page free</a></li>
        <li><a href="#segment-free">Segment Free</a></li>
        <li><a href="#arena-free">Arena Free</a></li>
      </ul>
    </li>
    <li><a href="#内存-abandon">内存 abandon</a>
      <ul>
        <li><a href="#abandoned-segment-list">abandoned segment list</a></li>
        <li><a href="#非主线程终止">非主线程终止</a></li>
        <li><a href="#page-abandon">page abandon</a></li>
        <li><a href="#segment-abandon">segment abandon</a></li>
      </ul>
    </li>
    <li><a href="#内存-collect">内存 collect</a>
      <ul>
        <li><a href="#page-collect">page collect</a></li>
        <li><a href="#heap-collect">heap collect</a></li>
      </ul>
    </li>
    <li><a href="#主要函数功能">主要函数功能</a></li>
    <li><a href="#slice-算法">Slice 算法</a></li>
    <li><a href="#commitdecommit">Commit/Decommit</a>
      <ul>
        <li><a href="#segment-commit">Segment Commit</a></li>
        <li><a href="#os-commit">OS Commit</a></li>
      </ul>
    </li>
    <li><a href="#初始化与退出">初始化与退出</a>
      <ul>
        <li><a href="#初始化析构时机">初始化/析构时机</a></li>
        <li><a href="#heap-初始化">Heap 初始化</a></li>
        <li><a href="#动态库-unload">动态库 unload</a></li>
      </ul>
    </li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="内存管理">内存管理</h1>
<p>Allocator 主要解决的问题包括：</p>
<ul>
<li>高性能的内存分配</li>
<li>避免内存碎片化，包括内部碎片和外部碎片</li>
<li>Slab 系统用来实现对象缓存池</li>
<li>安全性保障</li>
<li>统计分析能力</li>
</ul>
<p>高性能的内存分配是 allocator 永恒的主题。目前 allocator 的一般思路包括：</p>
<ul>
<li>减少线程间的竞争与同步，如 thread local cache，划分不同的 arena</li>
<li>按照 size 和 object 划分的 slab 系统</li>
<li>伙伴系统来减少外部碎片化</li>
<li>lock-free 的实现优化</li>
<li>对 huge allocate 进行特殊实现</li>
</ul>
<h1 id="mimalloc-原理概述">Mimalloc 原理概述</h1>
<p>先介绍下 mimalloc 中的几个术语：</p>
<ul>
<li>heap：每个线程一个默认 heap，线程所有的内存分配都经由本线程的 heap 完成分配。mimalloc 提供的 mi_heap_new api 也允许为线程创建另外的 heap，通过 mi_heap_malloc 完成在该 heap 上进行内存分配，mi_malloc 会在默认 heap 上进行分配。</li>
<li>segment：一个 segment 是一块大的内存(8MB on x64)，是实际从 os 中分配内存，然后用于 malloc 的内存区域，heap 只是用来管理 segment 和 page。2.0 之后的版本，一个 segment 被划分为多个 slice，多个 slice 可以组成一个 page，segment 对 slice 和 page 进行管理。同时 segments 的 metadata 也保存在 segment 开头几个 slice 中。一个 heap 可以有多个 segment，但 heap 并不对 segment 进行直接管理，heap 对 page 进行管理，但通过 page 可以得到 page 所在的 segment。</li>
<li>page：非内核的 memory page，指一大块内存，可能包含多个 memory page。 一个 segment 按照不同的 block size 可以划分为不同大小的 pages，一个 page 由一个或多个 slices 组成。一个 page 内，划分为多个同大小的 block， page 由 3 个 free-list（free-list, local-free-list, thread-free-list）对 blocks 进行管理。</li>
<li>block：最小的分配单元。一个 page 被划分为多个同大小的 blocks。</li>
<li>tld: 线程局部数据（mi_tld_t），用来保存线程相关数据，如线程的 heap 指针等。</li>
<li>arena: 不同的 allocator 有不同的含义，在 mimalloc 中，arena 代表 os 内存用于分配 large-block( 大于等于4MiB)。不同于 segment，arena 是被多个线程共享的。可能需要 arena 的场景包括将已有的大块内存整合进 mimalloc（可能通过 sbrk 获得的内存，mimalloc 主要使用 mmap），使用方式可以参考 arena 提供的相关 api，本篇不会重点介绍 arena。</li>
</ul>
<p>Mimalloc 为每个线程分配一个 heap，所有的分配和释放都只能通过该 heap(除非线程终止，会 abondon 到主线程)，从而减少线程间的竞争，同时增加了局部性。page 有 3 个 free-list:</p>
<ul>
<li>free-list: 该 page 可用的 block 链表</li>
<li>local-free-list：本线程已经 free 的 block 链表，当 free-list 为空时，会和 free-list 进行交换</li>
<li>thread-free-list：其他线程 free 的 block 链表</li>
</ul>
<p>通过 3 个 free-list 能尽可能的减少线程间的竞争。以上只是非常概括性的总结，真正的实现比这复杂，不是简单概括能够说清楚的。下面将先从数据结构进行分析，搞清楚各个数据结构之间的关系和相互作用，然后基于 linux 系统，从具体的场景进行源码分析。</p>
<h1 id="主要数据结构">主要数据结构</h1>
<h2 id="heap">Heap</h2>
<p>按照内存的划分关系：heaps -&gt; segments -&gt; pages -&gt; blocks。</p>
<blockquote>
<p>注：下面这种图是 1x 的版本，2x 版本把 segment 按照 slice 进行划分，但其他基本没有变化，二者的主要区别可以参考 <a href="https://zhuanlan.zhihu.com/p/365094561">https://zhuanlan.zhihu.com/p/365094561</a></p>
</blockquote>
<p><img src="mimalloc.png" alt=""></p>
<p>每个线程有自己的 heap，主线程的 heap 结构是静态初始化的，其他线程的 heap 在线程创建时进行分配。heap 自身的内存仅能从创建它的线程 allocate 和 deallocate，线程终止时，heap 被 deallocate。_mi_heap_default 是一个 thread-local 指针，指向默认 heap。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// A heap owns a set of pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">mi_heap_s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 所属 tld
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_tld_t</span><span class="o">*</span>             <span class="n">tld</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 一个加速 malloc 的优化，数组元素指向一个 page，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 该 page 可能包含有 index 大小的 free blocks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_page_t</span><span class="o">*</span>            <span class="n">pages_free_direct</span><span class="p">[</span><span class="n">MI_PAGES_DIRECT</span><span class="p">];</span>  <span class="c1">// optimize: array where every entry points a page with possibly free blocks in the corresponding queue for that size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// page 队列，每个 page 中 block 的 size 相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// heap 并不直接对 segment 进行管理， page 可能属于不同的 segment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// pages 不一定都有可用的 block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// pages 最后一个位置是没有 free block 的 pagas 链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_page_queue_t</span>       <span class="n">pages</span><span class="p">[</span><span class="n">MI_BIN_FULL</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>              <span class="c1">// queue of pages for each size class (or &#34;bin&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 其他线程 freed 的 block 链表, 用于把 page 从 full-list 中移除，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 每个 page 仅会有一个 block 添加到 thread_delayed_free
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// page 还有个 xthread_free，表示其他线程 freed 的 block，但仅包含该 page 的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_Atomic</span><span class="p">(</span><span class="n">mi_block_t</span><span class="o">*</span><span class="p">)</span>  <span class="n">thread_delayed_free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_threadid_t</span>         <span class="n">thread_id</span><span class="p">;</span>                           <span class="c1">// thread this heap belongs too
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// arena 是一个预先从 os 获取的大块内存，之后的分配实际从 arena 中分配，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 目前，mimalloc 仅对 huge page 进行 arena 分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_arena_id_t</span>         <span class="n">arena_id</span><span class="p">;</span>                            <span class="c1">// arena id if the heap belongs to a specific arena (or 0)  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uintptr_t</span>             <span class="n">cookie</span><span class="p">;</span>                              <span class="c1">// random cookie to verify pointers (see `_mi_ptr_cookie`)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 对 thread_delayed_free 的 next 指针做编解码，防止 overflow 攻击
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 编码规则： ((p^k2)&lt;&lt;&lt;k1)+k1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uintptr_t</span>             <span class="n">keys</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>                             <span class="c1">// two random keys used to encode the `thread_delayed_free` list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_random_ctx_t</span>       <span class="n">random</span><span class="p">;</span>                              <span class="c1">// random number context used for secure allocation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// pages 中 page 个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>                <span class="n">page_count</span><span class="p">;</span>                          <span class="c1">// total number of pages in the `pages` queues.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 最少的全 free 的 pages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// page 全 free 后进行 retire，如果超过一定时间没有被使用会被回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>                <span class="n">page_retired_min</span><span class="p">;</span>                    <span class="c1">// smallest retired index (retired pages are fully free, but still in the page queues)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 最多的全 free 的 pages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>                <span class="n">page_retired_max</span><span class="p">;</span>                    <span class="c1">// largest retired index into the `pages` array.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 线程内的 heap 链表，可以为 thread 新建其他 heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_heap_t</span><span class="o">*</span>            <span class="n">next</span><span class="p">;</span>                                <span class="c1">// list of heaps per thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 表示该 heap 的 page 不应该被回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span>                  <span class="n">no_reclaim</span><span class="p">;</span>                          <span class="c1">// `true` if this heap should not reclaim abandoned pages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>几个概念：</p>
<ul>
<li>retired：表示 page 或者 segment 已经没在使用了，可以还给 os 了，但为了防止又立马需要从 os 分配，所以给一个过期时间，在过期时间之内可以被再次回收使用。</li>
<li>abandoned：表示线程已经终止了，但是因为终止时，还有其他线程在使用之前 heap 分配的内存，不能直接 free，而是将 page 和 segment 转移到主线程。</li>
<li>reclaim：进行回收再利用</li>
</ul>
<p>注意，heap 自己的数据结构很小，segment 并不在 heap 内存区域内，heap 自己的内存可以通过 mimalloc 进行分配。</p>
<h2 id="segment">Segment</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// Segments are large allocated memory blocks (8mb on 64 bit) from
</span></span></span><span class="line"><span class="cl"><span class="c1">// the OS. Inside segments we allocated fixed size _pages_ that
</span></span></span><span class="line"><span class="cl"><span class="c1">// contain blocks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">mi_segment_s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// arena memory id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>            <span class="n">memid</span><span class="p">;</span>              <span class="c1">// memory id for arena allocation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span>              <span class="n">mem_is_pinned</span><span class="p">;</span>      <span class="c1">// `true` if we cannot decommit/reset/protect in this memory (i.e. when allocated using large OS pages)    
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span>              <span class="n">mem_is_large</span><span class="p">;</span>       <span class="c1">// in large/huge os pages?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span>              <span class="n">mem_is_committed</span><span class="p">;</span>   <span class="c1">// `true` if the whole segment is eagerly committed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>            <span class="n">mem_alignment</span><span class="p">;</span>      <span class="c1">// page alignment for huge pages (only used for alignment &gt; MI_ALIGNMENT_MAX)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>            <span class="n">mem_align_offset</span><span class="p">;</span>   <span class="c1">// offset for huge page alignment (only used for alignment &gt; MI_ALIGNMENT_MAX)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 是否允许 decommit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span>              <span class="n">allow_decommit</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">  <span class="c1">// decommit 的过期时间   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_msecs_t</span>        <span class="n">decommit_expire</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// delay decommit 的块 mask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// decommit_mask 并不是已经 decommit mask, 而是待 decommit 的 mask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// delay decommit 的目的是 reuse
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_commit_mask_t</span>  <span class="n">decommit_mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 已经 commit 的块 mask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_commit_mask_t</span>  <span class="n">commit_mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// abandoned 的链表指针，segment 是链表的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果不为空，说明该 segment 被 abondoned
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_Atomic</span><span class="p">(</span><span class="k">struct</span> <span class="nc">mi_segment_s</span><span class="o">*</span><span class="p">)</span> <span class="n">abandoned_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 下一个 segment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// from here is zero initialized
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">mi_segment_s</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>            <span class="c1">// the list of freed segments in the cache (must be first field, see `segment.c:mi_segment_init`)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// abandoned pages 个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>            <span class="n">abandoned</span><span class="p">;</span>          <span class="c1">// abandoned pages (i.e. the original owning thread stopped) (`abandoned &lt;= used`)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 每被访问一次会增加一次计数，超过 3 时，segment 会被 reclaim, 来限制 abandoned list 的长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>            <span class="n">abandoned_visits</span><span class="p">;</span>   <span class="c1">// count how often this segment is visited in the abandoned list (to force reclaim it it is too long)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 当前在用 page 个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>            <span class="n">used</span><span class="p">;</span>               <span class="c1">// count of pages in use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">uintptr_t</span>         <span class="n">cookie</span><span class="p">;</span>             <span class="c1">// verify addresses in debug mode: `mi_ptr_cookie(segment) == segment-&gt;cookie`  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// segments 实际的单元 slice 个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>            <span class="n">segment_slices</span><span class="p">;</span>      <span class="c1">// for huge segments this may be different from `MI_SLICES_PER_SEGMENT`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 用于保存元数据和 guard page 的 slice 个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>            <span class="n">segment_info_slices</span><span class="p">;</span> <span class="c1">// initial slices we are using segment info and possible guard pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// segment 的分类，huge page 一个 segment 仅有一个 page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// layout like this to optimize access in `mi_free`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_segment_kind_t</span> <span class="n">kind</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 实际的 slice 的个数，不是最小单元 slice 的个数，一个 slice 可以横跨多个单元 slice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>            <span class="n">slice_entries</span><span class="p">;</span>       <span class="c1">// entries in the `slices` array, at most `MI_SLICES_PER_SEGMENT`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 所属线程 id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_Atomic</span><span class="p">(</span><span class="n">mi_threadid_t</span><span class="p">)</span> <span class="n">thread_id</span><span class="p">;</span>      <span class="c1">// unique id of the thread owning this segment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// slice 单元数组，每个元素都是一个单元 slice，但实际有效的个数是 segment_slices
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// mi_segment_slices_end 函数用来得到最后的slice(page) 的 index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_slice_t</span>        <span class="n">slices</span><span class="p">[</span><span class="n">MI_SLICES_PER_SEGMENT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>  <span class="c1">// one more for huge blocks with large alignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">mi_segment_t</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>几个概念：</p>
<ul>
<li>decommit/commit:  是内存管理的术语
<ul>
<li>在 os 层面，分别意味着归还 os 已分配内存和申请内存。decommit 内存，不意味着 munmap(mimalloc 通过 mmap 分配内存)，虚拟地址空间依然可用，但实际的物理 page 已经被释放。实现上可能使用 <a href="https://man7.org/linux/man-pages/man2/madvise.2.html">madvice</a> MADV_DONTNEED。</li>
<li>在 segment 层面，把整个 segment 按照 MI_COMMIT_SIZE 块大小进行划分（比 slice 更大），通过 commit_mask 和 decommit_mask 两个 bit mask 进行管理，如果已经 commit 了，在相应位置标记 1。</li>
</ul>
</li>
<li>commit mask: bit map, 对 segment 的块进行管理，哪些已经 decommit，哪些是 commit 的</li>
<li>page/slice: page 和 slice 实际是一个东西，两者在数据结构上是一样的, slice 自己可以包含多个 slice, slice 的 slice_count 表示包含的 slice 的具体个数。详见下面的 slice 算法部分。</li>
</ul>
<p>mi_segment_s 是 Segment 的元数据(包括 page/slice 元数据)，放在 segment 的开头部分，整个 segment 的实际大小比 mi_segment_s 大(参考分配 segment 的 mi_segment_os_alloc 函数)，segment 的实际大小是 segment_slices * MI_SEGMENT_SLICE_SIZE(mi_segment_size)。mi_segment_s 也是保存在 slice 中, segment_info_slices 是实际元数据所占的单元 slice 个数。</p>
<h2 id="page">Page</h2>
<p>page 和 slice 的数据结构一致，一个 page 可能包含多个 slice, page 首个 slice 的 slice_offset 为 0。Pages 和 相关元数据都在一个 segment，这样能较少向 os 请求内存分配的次数，另外一个重要的原因是可以通过指针 p，通过对齐（segment 4m 对齐）的方式得到 p 所在的 page 的元数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">mi_page_s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 当前 page/slcie 所占单元 slice 个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// &#34;owned&#34; by the segment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span>              <span class="n">slice_count</span><span class="p">;</span>       <span class="c1">// slices in this page (0 if not a page)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 当前 slice 距 page 第一个 slice 的 offset, 0 表示 page 的第一个 slice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span>              <span class="n">slice_offset</span><span class="p">;</span>      <span class="c1">// distance from the actual page data slice (0 if a page)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 是否 page 内存被 reset 了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span>               <span class="nl">is_reset</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">// `true` if the page memory was reset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 是否 page 内存被 decommit 了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span>               <span class="nl">is_committed</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// `true` if the page virtual memory is committed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 是否被 0 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span>               <span class="nl">is_zero_init</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// `true` if the page was zero initialized
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// page 总的 committed block 个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// layout like this to optimize access in `mi_malloc` and `mi_free`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span>              <span class="n">capacity</span><span class="p">;</span>          <span class="c1">// number of blocks committed, must be the first field, see `segment.c:page_clear`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// page 总的 block 个数, 包括已经被 decommitted 的 blocks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span>              <span class="n">reserved</span><span class="p">;</span>          <span class="c1">// number of blocks reserved in memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 一些 flag 状态, 包括是否是 full，对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_page_flags_t</span>       <span class="n">flags</span><span class="p">;</span>             <span class="c1">// `in_full` and `has_aligned` flags (8 bits)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span>               <span class="nl">is_zero</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1">// `true` if the blocks in the free list are zero initialized
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// page retire 计数，为 0 时，表示需要被 free，目的是避免被 free 后，又需要立马分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span>               <span class="nl">retire_expire</span> <span class="p">:</span> <span class="mi">7</span><span class="p">;</span> <span class="c1">// expiration count for retired blocks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// free-blocks 链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_block_t</span><span class="o">*</span>           <span class="n">free</span><span class="p">;</span>              <span class="c1">// list of available free blocks (`malloc` allocates from this list)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 在用 block 个数, xthread_free 中的 block 依然算在 used，local_free 和 free 的不算做 used
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span>              <span class="n">used</span><span class="p">;</span>              <span class="c1">// number of blocks in use (including blocks in `local_free` and `thread_free`)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// page block 大小，每个 page 的 block 都是相同的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果为 0，表示 page 是 huge blocks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span>              <span class="n">xblock_size</span><span class="p">;</span>       <span class="c1">// size available in each block (always `&gt;0`)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 本线程释放的 blocks 链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_block_t</span><span class="o">*</span>           <span class="n">local_free</span><span class="p">;</span>        <span class="c1">// list of deferred free blocks by this thread (migrates to `free`)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 其他线程使用的 blocks 链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_Atomic</span><span class="p">(</span><span class="n">mi_thread_free_t</span><span class="p">)</span> <span class="n">xthread_free</span><span class="p">;</span>  <span class="c1">// list of deferred free blocks freed by other threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// page 所在 heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_Atomic</span><span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span>        <span class="n">xheap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// pages 链表指针, 可能指向同 thread 的其他 segment page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">mi_page_s</span><span class="o">*</span>     <span class="n">next</span><span class="p">;</span>              <span class="c1">// next page owned by this thread with the same `block_size`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">mi_page_s</span><span class="o">*</span>     <span class="n">prev</span><span class="p">;</span>              <span class="c1">// previous page owned by this thread with the same `block_size`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 64-bit 9 words, 32-bit 12 words, (+2 for secure)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cp">#if MI_INTPTR_SIZE==8
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="n">uintptr_t</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span> <span class="n">mi_page_t</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>几个概念：</p>
<ul>
<li>reset：表示内存已经不再使用了，但是有可能会最近再次使用, os 可以释放对应的物理 page 和 swap page。对于 segment 来说，该 page 依然是 commited 状态，而非 decommit 状态。不同于 decommit 会立即减少 RSS(Resident Set Size)。在实现上采用 <a href="https://man7.org/linux/man-pages/man2/madvise.2.html">madvise</a> MADV_FREE。</li>
</ul>
<h2 id="tld">TLD</h2>
<p>线程本地存储，用于管理线程相关的元数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// Thread local data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">mi_tld_s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// free 心跳计数，用于判断是否要执行注册的 defer-free 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 详见 deferred-free 模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span>  <span class="n">heartbeat</span><span class="p">;</span>     <span class="c1">// monotonic heartbeat count
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 防止 defer free 重入执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span>                <span class="n">recurse</span><span class="p">;</span>       <span class="c1">// true if deferred was called; used to prevent infinite recursion.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// backing heap，不能删除，默认指向 default heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 线程的其他堆被删除时，被释放的 segment 被 backing heap 接管
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_heap_t</span><span class="o">*</span>          <span class="n">heap_backing</span><span class="p">;</span>  <span class="c1">// backing heap of this thread (cannot be deleted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 当前线程堆链表头节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_heap_t</span><span class="o">*</span>          <span class="n">heaps</span><span class="p">;</span>         <span class="c1">// list of heaps in this thread (so we can abandon all when the thread terminates)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// segments 的 tld 元数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_segments_tld_t</span>   <span class="n">segments</span><span class="p">;</span>      <span class="c1">// segment tld
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// os tld
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_os_tld_t</span>         <span class="n">os</span><span class="p">;</span>            <span class="c1">// os tld
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 当前线程的统计信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_stats_t</span>          <span class="n">stats</span><span class="p">;</span>         <span class="c1">// statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 线程 default heap 和 tld 可以一次完成分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">mi_thread_data_s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// thread 主 Heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_heap_t</span>  <span class="n">heap</span><span class="p">;</span>  <span class="c1">// must come first due to cast in `_mi_heap_done`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 线程元数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_tld_t</span>   <span class="n">tld</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">mi_thread_data_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Segments thread local data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">mi_segments_tld_s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// slice bin 队列, 包含最多 slice_count 个 slice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_span_queue_t</span>     <span class="n">spans</span><span class="p">[</span><span class="n">MI_SEGMENT_BIN_MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>  <span class="c1">// free slice spans inside segments
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// segments 当前总数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>              <span class="n">count</span><span class="p">;</span>        <span class="c1">// current number of segments;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// segments 峰值总数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>              <span class="n">peak_count</span><span class="p">;</span>   <span class="c1">// peak number of segments
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// segments 当前总大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>              <span class="n">current_size</span><span class="p">;</span> <span class="c1">// current size of all segments
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// segments 峰值总大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>              <span class="n">peak_size</span><span class="p">;</span>    <span class="c1">// peak size of all segments
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_stats_t</span><span class="o">*</span>         <span class="n">stats</span><span class="p">;</span>        <span class="c1">// points to tld stats
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_os_tld_t</span><span class="o">*</span>        <span class="n">os</span><span class="p">;</span>           <span class="c1">// points to os stats
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">mi_segments_tld_t</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>线程元数据直接从系统分配，并且为了避免线程来回创建和销毁的分配开销，对 mi_thread_data_s 进行了缓存。非主线程元数据，只能在线程创建时进行创建，主线程的元素是静态变量。</p>
<h2 id="segment-bit-mask">Segment bit mask</h2>
<p>对内存空间，按照 segment 划分，每一个 segment 对应一个 bit 位，1 表示已分配，0 表示对应 segment 被 free。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">static</span> <span class="nf">_Atomic</span><span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span> <span class="n">mi_segment_map</span><span class="p">[</span><span class="n">MI_SEGMENT_MAP_WSIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>  <span class="c1">// 2KiB per TB with 64MiB segments
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="主要链表">主要链表</h2>
<p>对 mimalloc 主要的链表结构按照定义范围进行划分：</p>
<ul>
<li>全局
<ul>
<li>abandoned list(abandoned):  全局的 abandoned segments, 可以被其他线程按需回收</li>
<li>abandoned-visited list(abandoned_visited):  当从 abandoned list 取出 segment 进行 reclaim 时，如果发现 segment 不合适，会放入visited list，避免下面又被访问到，当 abandoned list 为空时， abandoned visited list 会迁移到 abandoned list，目的是减少线程间的竞争。</li>
</ul>
</li>
<li>TLD
<ul>
<li>heaps: 该线程的所有 heaps</li>
<li>slice spans(mi_span_queue_s)：该线程的 slice span bin 队列, 类似 heap 的 pages 队列 mi_page_queue_s，只是 mi_page_queue_s 是 page 包含最多 block_size 个  block，mi_span_queue_s 是 slice 包含最多 slice_count 个单元 slice。</li>
</ul>
</li>
<li>Heap
<ul>
<li>Segments:  segment 链表（非直接管理）</li>
<li>pages(mi_page_queue_s): page blocks(bin) 队列，page 包含最多 block_size 个  block</li>
<li>thread_delayed_free: 其他线程 free 的 blocks</li>
</ul>
</li>
<li>Segment
<ul>
<li>pages：该 segment 的 pages</li>
</ul>
</li>
<li>Page
<ul>
<li>free-list: freed blocks</li>
<li>local-free-list: 本地线程 free 的 blocks</li>
<li>thread-free-list: 其他线程 free 的 blocks，仅该 page</li>
</ul>
</li>
</ul>
<h2 id="主要-map">主要 map</h2>
<p>主要指一些 array， index 即为 key。</p>
<ul>
<li>Heap
<ul>
<li>pages_free_direct: 每个元素指向有 free 的 index*wsize  block size 的page，来加速 page 查找</li>
<li>Pages: 不同 block size 的 page 队列，最后一个元素为全 full 的 page 列表</li>
</ul>
</li>
</ul>
<h1 id="内存分配">内存分配</h1>
<p>Mimalloc 提供了多个 malloc 函数，如 mi_malloc, mi_zalloc_small 等，c 标准库中的各种 malloc 都有对应的版本，还有指定 heap 的mi_heap_malloc, mi_heap_zalloc等。下面的分析基于 mi_malloc。</p>
<p>Malloc 有 fast path 和 slow path。fast path 首先从 default heap 查找合适page，从 page 的 free-list 中完成分配。当无法查到到 page，或者 page 无法满足分配时，将进入 slow path，slow path 会进行一系列比较复杂的操作，比如进行 collect，进行 reclaim，或者从 os 分配 segment 等等。下面先从 fast path 讲起。</p>
<p>内存malloc 和 free 并不是两条独立的线，free 后的内存需要被 malloc 再次使用，会涉及 malloc 时，进行回收的过程，还会涉及到过多空闲内存时，向系统归还的问题。</p>
<p>进行内存分配时，按照分配的大小，分为了 small 和 huge</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// small size 最多允许 128 words，一个 word 是系统能一次处理的最大字节数
</span></span></span><span class="line"><span class="cl"><span class="c1">// https://en.wikipedia.org/wiki/Word_(computer_architecture)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MI_SMALL_WSIZE_MAX  (128)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// small size 的最大大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MI_SMALL_SIZE_MAX   (MI_SMALL_WSIZE_MAX*sizeof(void*))
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="fast-path">Fast path</h2>
<p>heap pages_free_direct 数组维护了有 index*wsize 的 free blocks 的 page，来加速 page 查找。如果有page 有 free 的 block，直接从 free-list 中移除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="n">mi_decl_restrict</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">mi_heap_malloc_small_zero</span><span class="p">(</span><span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">heap</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero</span><span class="p">)</span> <span class="n">mi_attr_noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 从 heap pages_free_direct 中获取有 size free block的 page, 如果没有合适的 page，返回值指向一个空 page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// pages_free_direct 是用于加快查找有 free block 的 page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_page_t</span><span class="o">*</span> <span class="n">page</span> <span class="o">=</span> <span class="n">_mi_heap_get_free_small_page</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="n">MI_PADDING_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 从 page 中分配, 如果 page 没有合适的 block，从 heap 中进行generic分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">_mi_page_malloc</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="n">MI_PADDING_SIZE</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 从 heap pages_free_direct 中获取有 size free block的 page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="n">mi_page_t</span><span class="o">*</span> <span class="nf">_mi_heap_get_free_small_page</span><span class="p">(</span><span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">heap</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">MI_SMALL_SIZE_MAX</span> <span class="o">+</span> <span class="n">MI_PADDING_SIZE</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 计算 small size 换成 word 后的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">_mi_wsize_from_size</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">MI_PAGES_DIRECT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 取回有 free blocks 的 page，有可能为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">pages_free_direct</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Fast allocation in a page: just pop from the free list.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Fall back to generic allocation only if the list is empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">extern</span> <span class="kr">inline</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">_mi_page_malloc</span><span class="p">(</span><span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">heap</span><span class="p">,</span> <span class="n">mi_page_t</span><span class="o">*</span> <span class="n">page</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero</span><span class="p">)</span> <span class="n">mi_attr_noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_block_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">block</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// slow path
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="n">mi_unlikely</span><span class="p">(</span><span class="n">block</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">_mi_malloc_generic</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// fast path
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// pop from the free list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 增加 block 使用计数，page 中的 block 大小相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">page</span><span class="o">-&gt;</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 从链表移除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">page</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">mi_block_next</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">block</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="slow-path">Slow path</h2>
<p>先利用这个时机进行 defer free，再把其他线程 delay free 的 block 进行 free，加入到 free-list, 如果依然没有合适的 free block，从全局的 abandoned list 回收 segment，后面就类似于 fast path。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// Generic allocation routine if the fast path (`alloc.c:mi_page_malloc`) does not succeed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note: in debug mode the size includes MI_PADDING_SIZE and might have overflowed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The `huge_alignment` is normally 0 but is set to a multiple of MI_SEGMENT_SIZE for
</span></span></span><span class="line"><span class="cl"><span class="c1">// very large requested alignments in which case we use a huge segment.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">_mi_malloc_generic</span><span class="p">(</span><span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">heap</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zero</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">huge_alignment</span><span class="p">)</span> <span class="n">mi_attr_noexcept</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 执行使用方注册的 deferred free
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// call potential deferred free routines
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_mi_deferred_free</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// free 其他线程 delay free 的 blocks, 会填充到 free-list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// free delayed frees from other threads (but skip contended ones)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_mi_heap_delayed_free_partial</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// find (or allocate) a page of the right size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mi_page_t</span><span class="o">*</span> <span class="n">page</span> <span class="o">=</span> <span class="n">mi_find_page</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">huge_alignment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">mi_unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// first time out of memory, try to collect and retry the allocation once more
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 如果没有合适的 page，进行一次 collect, 会从全局的 abandoned list 中回收 segment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">mi_heap_collect</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="nb">true</span> <span class="cm">/* force */</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">page</span> <span class="o">=</span> <span class="n">mi_find_page</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">huge_alignment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果没有合适的 page，返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="n">mi_unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// out of memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 因为都是在本线程 heap 中 page，所以 page 已经是有效的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and try again, this time succeeding! (i.e. this should never recurse through _mi_page_malloc)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="n">mi_unlikely</span><span class="p">(</span><span class="n">zero</span> <span class="o">&amp;&amp;</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">xblock_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// note: we cannot call _mi_page_malloc with zeroing for huge blocks; we zero it afterwards in that case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">_mi_page_malloc</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// huge block 需要再分配后进行置 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">_mi_memzero_aligned</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mi_page_usable_block_size</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">_mi_page_malloc</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">zero</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="huge">Huge</h2>
<p>Huge block 的分配总是走 slow path。分配的 size 按照 huge_alignment（MI_SEGMENT_SIZE 的倍数） 进行对齐，只能在 huge segment 进行分配，一个 huge page 就一个 block。</p>
<h2 id="查找-free-page">查找 Free Page</h2>
<p>根据请求的 page 大小，计算得到 bin 大小，在 mi_heap_s 的 pages 对应的槽得到 page 队列，如果队列不为空，得到队列的第一个 page，先对 page 进行 thread-free list 回收，然后判断是否 local-free  是否为空，如果不为空，且 free-list（大概率，不然会走 fast path） 为空，将 local-free 设置为 free-list。如果上述一番操作后，page 的 free-list 依然为空，则在 page 队列的其他 page 中进行查找。如果在队列中都没有找到，则在已经即将 retired 的 page 中查找。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="n">mi_page_queue_t</span><span class="o">*</span> <span class="nf">mi_page_queue</span><span class="p">(</span><span class="k">const</span> <span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">heap</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">&amp;</span><span class="p">((</span><span class="n">mi_heap_t</span><span class="o">*</span><span class="p">)</span><span class="n">heap</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">_mi_bin</span><span class="p">(</span><span class="n">size</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="内存-free">内存 free</h1>
<p>当 owner 线程 free block 时， block 会加入 page 的 local_free 链表。当非 owner 线程 free 时， block 会加入到 page 的 xthread_free。xthread_free 的 block，依然算作 used blocks，xthread_free 被</p>
<h2 id="defer-free">Defer free</h2>
<p>Mimallo 首先从 free-list 分配内存，当 free-list 为空时，thread-local-list 成为新的 free-list。这种机制建立一个简单的时钟，即只有在分配若干次后，free-list 才会为空，在这个时候，就可以进行一些比较昂贵的操作：</p>
<ul>
<li>mimalloc 提供了 mi_register_deferred_free 函数，让应用可以利用这个时间节点进行一些操作，如减少程序语言对象的引用计数</li>
<li>进行 thread-free-list 的回收</li>
<li>因为是每个 page 一个 free-list, 而每个 page 一次分配的大小是确定的，在确定的次数后，一个 free-list 会为空， 建立了一个简单的 allocate 分配心跳</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="n">mi_cdecl</span> <span class="n">mi_deferred_free_fun</span><span class="p">)(</span><span class="kt">bool</span> <span class="n">force</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">heartbeat</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">mi_decl_export</span> <span class="kt">void</span> <span class="nf">mi_register_deferred_free</span><span class="p">(</span><span class="n">mi_deferred_free_fun</span><span class="o">*</span> <span class="n">deferred_free</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="n">mi_attr_noexcept</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所谓 defer free，指允许使用方将一批待释放的内存，在某些特定的时候集中释放，比较场景的如编程语言 GC。当执行 slow path 时，如果使用方有注册 deferred free 函数，会先执行 deffer free 函数，deffer free 可能会释放内存占用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// mi_register_deferred_free 函数用于注册 defer free 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="n">mi_deferred_free_fun</span><span class="o">*</span> <span class="k">volatile</span> <span class="n">deferred_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// defer free 的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="nf">_Atomic</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">deferred_arg</span><span class="p">;</span> <span class="c1">// = NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">_mi_deferred_free</span><span class="p">(</span><span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">heap</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">force</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">heap</span><span class="o">-&gt;</span><span class="n">tld</span><span class="o">-&gt;</span><span class="n">heartbeat</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">deferred_free</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">tld</span><span class="o">-&gt;</span><span class="n">recurse</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 避免重入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">heap</span><span class="o">-&gt;</span><span class="n">tld</span><span class="o">-&gt;</span><span class="n">recurse</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 执行 defer free 函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">deferred_free</span><span class="p">(</span><span class="n">force</span><span class="p">,</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">tld</span><span class="o">-&gt;</span><span class="n">heartbeat</span><span class="p">,</span> <span class="n">mi_atomic_load_ptr_relaxed</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="o">&amp;</span><span class="n">deferred_arg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">heap</span><span class="o">-&gt;</span><span class="n">tld</span><span class="o">-&gt;</span><span class="n">recurse</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="heap-delayed-free">Heap delayed free</h2>
<p>当一个 page 的所有 block 都被分配时，page 处于 full 状态。一个 full 状态的 page 无法进行有效的分配，当下次分配时，不应该被遍历进行查找（参考 paper 的 full list 章节）。mimalloc heap 维护一个 full page list，即 heap pages 数组的最后一个。</p>
<p>当  non-local free block 时， 需要通知 owner heap 该 page 不在是 full page。但如何通知 owner 线程呢，而且尽可能的不使用锁等比较昂贵的线程同步。 Mimalloc 通过 heap delayed free 来实现。当一个 full page 第一次 free block 时，把要 free 的 block 添加到 heap 的 thread_delayed_free list 上，之后的 free 正常的添加到 page 的thread_delayed_free。 当进行 generic malloc 时，会先进行 heap 的 delayed free，即可以把 page 从 full-list 中移除。一个 page 只会添加一个 block 到 heap 的 thread_delayed_free，因为只需要一个 block 被 free， page 就不在是 full。</p>
<p>mi_thread_free_t 的最低两位 bit 用作 delay flag(mi_delayed_e)，总有 4 种状态:</p>
<ul>
<li>当线程被移入 full-list 时会设置 MI_USE_DELAYED_FREE，表示下一次 free block 时，需要添加到 heap 的 thread_delayed_free。</li>
<li>在 full page 第一次 free block 并添加到 heap 的 thread_delayed_free 期间，会设置 MI_DELAYED_FREEING，这个时候非 owner 线程正在访问 owner 线程的 heap，需要确保 heap 的有效性，避免 heap 所在线程终止。</li>
<li>当第一次 free 的 block 添加到 heap 的 thread_delayed_free后，设置 MI_NO_DELAYED_FREE，之后该 page 的 free 都直接添加page 的 xthread_free。</li>
<li>当线程终止时，被其他线程使用的 page 会被 abandon，此期间会设置 MI_NEVER_DELAYED_FREE，因为已经和之前的 heap 解除了关系。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// Thread free list.
</span></span></span><span class="line"><span class="cl"><span class="c1">// We use the bottom 2 bits of the pointer for mi_delayed_t flags
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="n">uintptr_t</span> <span class="n">mi_thread_free_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// The delayed flags are used for efficient multi-threaded free-ing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">enum</span> <span class="nc">mi_delayed_e</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">MI_USE_DELAYED_FREE</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// push on the owning heap thread delayed list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">MI_DELAYED_FREEING</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// temporary: another thread is accessing the owning heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">MI_NO_DELAYED_FREE</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// optimize: push on page local thread free queue if another block is already in the heap thread delayed free list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">MI_NEVER_DELAYED_FREE</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1">// sticky, only resets on page reclaim
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">mi_delayed_t</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>_mi_free_block_mt 函数在 non-local free 时被调用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// multi-threaded free (or free in huge block if compiled with MI_HUGE_PAGE_ABANDON)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="n">mi_decl_noinline</span> <span class="kt">void</span> <span class="nf">_mi_free_block_mt</span><span class="p">(</span><span class="n">mi_page_t</span><span class="o">*</span> <span class="n">page</span><span class="p">,</span> <span class="n">mi_block_t</span><span class="o">*</span> <span class="n">block</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Try to put the block on either the page-local thread free list, or the heap delayed free list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_thread_free_t</span> <span class="n">tfreex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">use_delayed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_thread_free_t</span> <span class="n">tfree</span> <span class="o">=</span> <span class="n">mi_atomic_load_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">xthread_free</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">use_delayed</span> <span class="o">=</span> <span class="p">(</span><span class="n">mi_tf_delayed</span><span class="p">(</span><span class="n">tfree</span><span class="p">)</span> <span class="o">==</span> <span class="n">MI_USE_DELAYED_FREE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">mi_unlikely</span><span class="p">(</span><span class="n">use_delayed</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 如果是 MI_USE_DELAYED_FREE，将 block 添加到 heap 的 thread_delayed_free
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 并设置 MI_DELAYED_FREEING，保证 heap 的有效性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// unlikely: this only happens on the first concurrent free in a page that is in the full list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">tfreex</span> <span class="o">=</span> <span class="n">mi_tf_set_delayed</span><span class="p">(</span><span class="n">tfree</span><span class="p">,</span><span class="n">MI_DELAYED_FREEING</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 非 MI_USE_DELAYED_FREE，包括了 MI_DELAYED_FREEING，MI_NO_DELAYED_FREE，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 直接添加到 page 的 xthread_free， 主要不会修改 delay-flag
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// usual: directly add to page thread_free list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">mi_block_set_next</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">mi_tf_block</span><span class="p">(</span><span class="n">tfree</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="n">tfreex</span> <span class="o">=</span> <span class="n">mi_tf_set_block</span><span class="p">(</span><span class="n">tfree</span><span class="p">,</span><span class="n">block</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">mi_atomic_cas_weak_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">xthread_free</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfree</span><span class="p">,</span> <span class="n">tfreex</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="n">mi_unlikely</span><span class="p">(</span><span class="n">use_delayed</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 添加到 heap 的 thread_delayed_free，MI_DELAYED_FREEING 能保证 heap 的有效性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// racy read on `heap`, but ok because MI_DELAYED_FREEING is set (see `mi_heap_delete` and `mi_heap_collect_abandon`)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mi_heap_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">heap</span> <span class="o">=</span> <span class="p">(</span><span class="n">mi_heap_t</span><span class="o">*</span><span class="p">)(</span><span class="n">mi_atomic_load_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">xheap</span><span class="p">));</span> <span class="c1">//mi_page_heap(page);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">heap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">heap</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// add to the delayed free list of this heap. (do this atomically as the lock only protects heap memory validity)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">mi_block_t</span><span class="o">*</span> <span class="n">dfree</span> <span class="o">=</span> <span class="n">mi_atomic_load_ptr_relaxed</span><span class="p">(</span><span class="n">mi_block_t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">thread_delayed_free</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mi_block_set_nextx</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span><span class="n">block</span><span class="p">,</span><span class="n">dfree</span><span class="p">,</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">mi_atomic_cas_ptr_weak_release</span><span class="p">(</span><span class="n">mi_block_t</span><span class="p">,</span><span class="o">&amp;</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">thread_delayed_free</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dfree</span><span class="p">,</span> <span class="n">block</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// and reset the MI_DELAYED_FREEING flag
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">tfree</span> <span class="o">=</span> <span class="n">mi_atomic_load_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">xthread_free</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">tfreex</span> <span class="o">=</span> <span class="n">tfree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">mi_tf_delayed</span><span class="p">(</span><span class="n">tfree</span><span class="p">)</span> <span class="o">==</span> <span class="n">MI_DELAYED_FREEING</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">tfreex</span> <span class="o">=</span> <span class="n">mi_tf_set_delayed</span><span class="p">(</span><span class="n">tfree</span><span class="p">,</span><span class="n">MI_NO_DELAYED_FREE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">mi_atomic_cas_weak_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">xthread_free</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tfree</span><span class="p">,</span> <span class="n">tfreex</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="regular-free">Regular free</h2>
<p>如果是 local-free，把 block 添加到 local_free list, 当 page 的 blocks 都 free 时，设置 page 的过期时间，当 page 从 full 变为 non-full 时，从 full-list 中移除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_mi_free_block</span><span class="p">(</span><span class="n">mi_page_t</span><span class="o">*</span> <span class="n">page</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">local</span><span class="p">,</span> <span class="n">mi_block_t</span><span class="o">*</span> <span class="n">block</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// and push it on the free list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//const size_t bsize = mi_page_block_size(page);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="n">mi_likely</span><span class="p">(</span><span class="n">local</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// owning thread can free a block directly
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="n">mi_unlikely</span><span class="p">(</span><span class="n">mi_check_is_double_free</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">block</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mi_check_padding</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#if (MI_DEBUG!=0) &amp;&amp; !MI_TRACK_ENABLED
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mi_page_is_huge</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>   <span class="c1">// huge page content may be already decommitted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">memset</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">MI_DEBUG_FREED</span><span class="p">,</span> <span class="n">mi_page_block_size</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">mi_block_set_next</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">local_free</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">page</span><span class="o">-&gt;</span><span class="n">local_free</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">page</span><span class="o">-&gt;</span><span class="n">used</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">mi_unlikely</span><span class="p">(</span><span class="n">mi_page_all_free</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">_mi_page_retire</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="n">mi_unlikely</span><span class="p">(</span><span class="n">mi_page_is_in_full</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">_mi_page_unfull</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">_mi_free_block_mt</span><span class="p">(</span><span class="n">page</span><span class="p">,</span><span class="n">block</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="page-free">Page free</h2>
<p>当 page 所有 block free 时，整个 page 应该被 free，但为了防止 page 被 free 后，内存分配又需要再次分配 page，如果 page 是该 block size 下唯一一个 page， page 不会被立马 free，而是设置一个 retire_expire 时间，只有在超过 retire_expire 且没有被再次使用时，才 free 掉。这种 case 下， page 也不会移入 full-list。</p>
<p>如果 page 不是该 block size 下唯一一个 page，将执行 page free。首先从 heap page-queue 中移除，减少 heap 的 page 计数，设置 page 的 in_full flag 为 false，设置 page 的 heap 为 null。</p>
<p>把需要 free 的 page slices 进行左右合并，更新 segment 的 slice 信息。如果允许 decommit，decommit 该 slice。然后将合并后的 slice 重新加入对应的 span-queue，最后更新 segment 的 page 使用计数。如果 segment 的所有 page 都不在使用，将执行 segment 的 free。</p>
<h2 id="segment-free">Segment Free</h2>
<p>把 segment 和 page 的元数据 slice 和 另外一个已经完成 free 的 page slice(page 合并后的) 从 span-queue 中移除。设置 segment 的 thead_id 为 0，设置对应 segment-bit-mask bit 位为 0。等到 abandoned_readers 的个数为 0 时，执行 arena free。</p>
<h2 id="arena-free">Arena Free</h2>
<p>如果 memid 为 MI_MEMID_OS（大部分场景），会执行 os-free(munmap)，即真正的内存 free。 decommit 和 reset 不影响虚拟地址空间。</p>
<h1 id="内存-abandon">内存 abandon</h1>
<h2 id="abandoned-segment-list">abandoned segment list</h2>
<p>当线程终止时，该线程 heaps 的 page 还可能被其他线程使用，不能直接将 segments 删除，另外线程已分配的 segment，可以被其他线程进行回收复用。全局的 abandoned-segment list 用来管理被终止线程abandon 的 segments。</p>
<h2 id="非主线程终止">非主线程终止</h2>
<p>线程终止时，_mi_heap_done 被调用，先设置 default-heap 为空堆，然后删除除 heap_backing（一般即为默认堆） 以外的其他 heap（heap 只是管理数据，segment 才是真正 malloc 的内存所在地）。删除 heap 时，会将 heap 管理的 segment 都转移到 heap_backing，然后由 heap_backing 将 abandoned 的 segments 添加到全局的 abandoned-segment list。最后释放 mi_thread_data_t 数据，由于默认堆也属于 mi_thread_data_t 的一部分，heap_backing 也被删除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// Free the thread local default heap (called from `mi_thread_done`)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">_mi_heap_done</span><span class="p">(</span><span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">heap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mi_heap_is_initialized</span><span class="p">(</span><span class="n">heap</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置默认 heap 为 _mi_heap_empty（一个全局变量）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// reset default heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_mi_heap_set_default_direct</span><span class="p">(</span><span class="n">_mi_is_main_thread</span><span class="p">()</span> <span class="o">?</span> <span class="o">&amp;</span><span class="nl">_mi_heap_main</span> <span class="p">:</span> <span class="p">(</span><span class="n">mi_heap_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_mi_heap_empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// heap_backing 已经即为 thread 默认堆
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// switch to backing heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">heap</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">tld</span><span class="o">-&gt;</span><span class="n">heap_backing</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mi_heap_is_initialized</span><span class="p">(</span><span class="n">heap</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// delete all non-backing heaps in this thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">tld</span><span class="o">-&gt;</span><span class="n">heaps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">// save `next` as `curr` will be freed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">heap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">mi_assert_internal</span><span class="p">(</span><span class="o">!</span><span class="n">mi_heap_is_backing</span><span class="p">(</span><span class="n">curr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 会将正在使用的 page 转移到 heap_backing，并free heap 的 内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">mi_heap_delete</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">heap</span><span class="o">-&gt;</span><span class="n">tld</span><span class="o">-&gt;</span><span class="n">heaps</span> <span class="o">==</span> <span class="n">heap</span> <span class="o">&amp;&amp;</span> <span class="n">heap</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">mi_heap_is_backing</span><span class="p">(</span><span class="n">heap</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// collect if not the main thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">heap</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">_mi_heap_main</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 会遍历 heap_backing 中 abandoned 的 pages 并执行 page abandon
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_mi_heap_collect_abandon</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// free if not the main thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">heap</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">_mi_heap_main</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// the following assertion does not always hold for huge segments as those are always treated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// as abondened: one may allocate it in one thread, but deallocate in another in which case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the count can be too large or negative. todo: perhaps not count huge segments? see issue #363
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// mi_assert_internal(heap-&gt;tld-&gt;segments.count == 0 || heap-&gt;thread_id != _mi_thread_id());
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mi_thread_data_free</span><span class="p">((</span><span class="n">mi_thread_data_t</span><span class="o">*</span><span class="p">)</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mi_thread_data_collect</span><span class="p">();</span> <span class="c1">// free cached thread metadata
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cp">#if 0</span><span class="c">
</span></span></span><span class="line"><span class="cl"><span class="c">    // never free the main thread even in debug mode; if a dll is linked statically with mimalloc,
</span></span></span><span class="line"><span class="cl"><span class="c">    // there may still be delete/free calls after the mi_fls_done is called. Issue #207
</span></span></span><span class="line"><span class="cl"><span class="c">    _mi_heap_destroy_pages(heap);
</span></span></span><span class="line"><span class="cl"><span class="c">    mi_assert_internal(heap-&gt;tld-&gt;heap_backing == &amp;_mi_heap_main);
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="cp">    #endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当执行 _mi_heap_collect_abandon 时，会遍历 heap 的所有 page，如果 page 有 block 被使用，将执行 page 的 abandon，否则 page 被 free。</p>
<h2 id="page-abandon">page abandon</h2>
<p>当 abandon  page 时，首先从 page 队列中移除该 page，设置 page 的 delay-free flag 为 MI_NEVER_DELAYED_FREE，避免heap 产生任何 delay-free 的联系（详见 delay-free）, 设置 page.xheap 为 null，增加 segment.abandoned, 当 segment.used 等于 segment.abandoned 时，表示 segment 所有 page 都被 abandoned 了(abandoned 的 page 会算在 used)，segment 也可以 abandon 了。详见 _mi_page_abandon 函数。</p>
<h2 id="segment-abandon">segment abandon</h2>
<p>Segment abandon 时，先把 slice 的信息从 mi_segments_tld_t 中抹掉，然后设置 segment.thread_id 为 0，最后加入 abandoned-list。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">mi_segment_abandon</span><span class="p">(</span><span class="n">mi_segment_t</span><span class="o">*</span> <span class="n">segment</span><span class="p">,</span> <span class="n">mi_segments_tld_t</span><span class="o">*</span> <span class="n">tld</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 所有 page 都是 abandoned
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">==</span> <span class="n">segment</span><span class="o">-&gt;</span><span class="n">abandoned</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 有效的 page 个数不为 0，page 被 free 时，used 会减一
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 之前不是 abandoned
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">mi_atomic_load_ptr_relaxed</span><span class="p">(</span><span class="n">mi_segment_t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">abandoned_next</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">abandoned_visits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_assert_expensive</span><span class="p">(</span><span class="n">mi_segment_is_valid</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span><span class="n">tld</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// remove the free pages from the free page queues
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_slice_t</span><span class="o">*</span> <span class="n">slice</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 最后一个有效 slice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">mi_slice_t</span><span class="o">*</span> <span class="n">end</span> <span class="o">=</span> <span class="n">mi_segment_slices_end</span><span class="p">(</span><span class="n">segment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">slice</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 都是 page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">slice</span><span class="o">-&gt;</span><span class="n">slice_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">slice</span><span class="o">-&gt;</span><span class="n">slice_offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">slice</span><span class="o">-&gt;</span><span class="n">xblock_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// a free page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 从 tld 的 span 队列移除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">mi_segment_span_remove_from_queue</span><span class="p">(</span><span class="n">slice</span><span class="p">,</span><span class="n">tld</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">slice</span><span class="o">-&gt;</span><span class="n">xblock_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// but keep it free
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">slice</span> <span class="o">=</span> <span class="n">slice</span> <span class="o">+</span> <span class="n">slice</span><span class="o">-&gt;</span><span class="n">slice_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// perform delayed decommits
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 不一定所有 delayed block 都是 decommited
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_segment_delayed_decommit</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">mi_option_is_enabled</span><span class="p">(</span><span class="n">mi_option_abandoned_page_decommit</span><span class="p">)</span> <span class="cm">/* force? */</span><span class="p">,</span> <span class="n">tld</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">);</span>    
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// all pages in the segment are abandoned; add it to the abandoned list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_mi_stat_increase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tld</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">segments_abandoned</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_segments_track_size</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">mi_segment_size</span><span class="p">(</span><span class="n">segment</span><span class="p">)),</span> <span class="n">tld</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 不再和任何线程关联
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">segment</span><span class="o">-&gt;</span><span class="n">thread_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_atomic_store_ptr_release</span><span class="p">(</span><span class="n">mi_segment_t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">abandoned_next</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">segment</span><span class="o">-&gt;</span><span class="n">abandoned_visits</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// from 0 to 1 to signify it is abandoned
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 加入全局的 abandoned 链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_abandoned_push</span><span class="p">(</span><span class="n">segment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="内存-collect">内存 collect</h1>
<p>所谓 collect，包含了 free 和 abandon 两种内存操作，将两种操作实现在一个流程中，使用 collect 的类型进行区分。free 包括迁移 local-free 和 thread-free 到 free-list, 释放不再使用的 page。abandon 即线程终止时，abandon 还在使用的 page 和 segment。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="nc">mi_collect_e</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">MI_NORMAL</span><span class="p">,</span> <span class="c1">// 仅 free
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">MI_FORCE</span><span class="p">,</span> <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">MI_ABANDON</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">mi_collect_t</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>何时需要进行 collect：</p>
<ul>
<li>generic malloc 找不到 page 可用 page 时</li>
<li>windows 上 mimalloc 静态链接到静态库，而静态库 unload 时</li>
<li>macos 上，面临内存压力时</li>
<li>线程终止 abandon heap 时</li>
</ul>
<h2 id="page-collect">page collect</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// 将 xthread_free 转移到 local_free， 将 local_free 转移到 free-list
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果 force 为 false，只有在 free-list 为空时才将 local_free 转移到 free-list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">_mi_page_free_collect</span><span class="p">(</span><span class="n">mi_page_t</span><span class="o">*</span> <span class="n">page</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">force</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">page</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// collect the thread free list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">||</span> <span class="n">mi_page_thread_free</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// quick test to avoid an atomic operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 将 xthread_free 转移到 local_free
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_mi_page_thread_free_collect</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// and the local free list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">local_free</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">mi_likely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// usual case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">page</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">local_free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">page</span><span class="o">-&gt;</span><span class="n">local_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">page</span><span class="o">-&gt;</span><span class="n">is_zero</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">force</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// append -- only on shutdown (force) as this is a linear operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">mi_block_t</span><span class="o">*</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">local_free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">mi_block_t</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">((</span><span class="n">next</span> <span class="o">=</span> <span class="n">mi_block_next</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tail</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tail</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">mi_block_set_next</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">page</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">local_free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">page</span><span class="o">-&gt;</span><span class="n">local_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">page</span><span class="o">-&gt;</span><span class="n">is_zero</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="o">!</span><span class="n">force</span> <span class="o">||</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">local_free</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 先进行 page 的 collect，如果 page 为空，free page，如果 page 不为空，且 collect 等于 abandon 时，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 会进行 page 的 abandon
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">mi_heap_page_collect</span><span class="p">(</span><span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">heap</span><span class="p">,</span> <span class="n">mi_page_queue_t</span><span class="o">*</span> <span class="n">pq</span><span class="p">,</span> <span class="n">mi_page_t</span><span class="o">*</span> <span class="n">page</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg_collect</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg2</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">MI_UNUSED</span><span class="p">(</span><span class="n">arg2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">MI_UNUSED</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">mi_heap_page_is_valid</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">pq</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_collect_t</span> <span class="n">collect</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">mi_collect_t</span><span class="o">*</span><span class="p">)</span><span class="n">arg_collect</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">_mi_page_free_collect</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">collect</span> <span class="o">&gt;=</span> <span class="n">MI_FORCE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">mi_page_all_free</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// no more used blocks, free the page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// note: this will free retired pages as well.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_mi_page_free</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pq</span><span class="p">,</span> <span class="n">collect</span> <span class="o">&gt;=</span> <span class="n">MI_FORCE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">collect</span> <span class="o">==</span> <span class="n">MI_ABANDON</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// still used blocks but the thread is done; abandon the page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_mi_page_abandon</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// don&#39;t break
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="heap-collect">heap collect</h2>
<p>在执行 _mi_abandoned_collect 时，如果 abandoned-list 中有 segment 已经不再使用了，会在线程终止时回收该 segment，会 free 掉该 segment 的所有 pages。</p>
<h1 id="主要函数功能">主要函数功能</h1>
<ul>
<li>_mi_ptr_segment： 得到指针所在 segment，用于得到 page， block 所在 segment</li>
<li>_mi_segment_page_of: 得到指针所在 page，主要用于得到 block 所在 page</li>
<li>delayed_free
<ul>
<li>_mi_heap_delayed_free_partial: free heap 的 thread_delayed_free，如果之前 page 为 full，会从 full 队列中移除。free block 还可能会导致 free page， free segment。此不要求所有的 thread_delayed_free 被清空。</li>
<li>_mi_heap_delayed_free_all: 同 _mi_heap_delayed_free_partial，但要求 thread_delayed_free 被清空。</li>
</ul>
</li>
<li>retired
<ul>
<li>_mi_heap_collect_retired: 将 heap 中，已经满足 retire 条件的 page free。</li>
</ul>
</li>
<li>Collect
<ul>
<li>mi_heap_page_collect: 如果 page all free， free page，如果是 abandon，添加到 abandoned-list
<ul>
<li>_mi_page_free_collect: 将 local_free 添加到 free
<ul>
<li>_mi_page_thread_free_collect: 将 xthread_free 添加到 local_free</li>
</ul>
</li>
</ul>
</li>
<li>_mi_abandoned_collect: 如果  abandoned segment 不再使用了，进行 segment 的回收
<ul>
<li>mi_segment_check_free: free blocks，并检查是否和合适的 block_size</li>
</ul>
</li>
</ul>
</li>
<li>decommit
<ul>
<li>mi_segment_delayed_decommit: de-commit 所有 delay de-commit 的 blocks</li>
<li>_mi_heap_collect_abandon: 进行 collect 的主要入口。先执行 deferred-free，然后进行 abandon 回收，执行 delay-free，释放超过过期时间的 pages。</li>
<li>mi_segment_reclaim: 回收一个 abandoned 的 segment，如果 segment 的 page 没有被使用，则 free 掉 page，如果 segment 的所有 page 都被 free，整个 segment 被 free。如果 segment 的 page 还在被使用，则把 page 回收加入到 page 的 page 队列中。</li>
</ul>
</li>
</ul>
<h1 id="slice-算法">Slice 算法</h1>
<p>1.x 版本和 2.x 版本对 segment 的管理方式有很大的不同，2.x 版本采用 slice 算法来减少内存碎片，提高内存利用率。segment 被划分为 MI_SLICES_PER_SEGMENT 个 slice(64KiB on 64-bit，32KiB on 32-bit)，当从 segment 分配一个 page 时，会首先计算 page 需要的 slice 的个数，通过 slice 个数，计算 spans 所对应的 bin，然后从 bin 开始的队列开始找能满足 page 大小的 slice，如果能满足，对 slice 进行相应的分割，如果此 bin 没有找到对应的 slice，比如span 为空，则想 bin 更高的 span 继续寻找。</p>
<p>mimalloc 为线程所有 segments 维护了一个 spans, 每一个 slot（bin） 对应一段范围的 slice， mi_span_queue_t 是一个简单的链表，包含了slice 范围在 bin 范围内的所有 slice。同一个 span 的 slice 的 slice_count 不一定相同。</p>
<p>mi_slice_t 和 mi_page_t 是同一个类型，只不过 mi_page_t 表示一段 slice 的开头，要求 slice_offset 为 0。一个 page 包含多个 slice，而 slice 也可能包含多个 slice(page-data-slice)，mi_slice_t 即用来描述最小单元 slice(mi_segment_s 中)，也用来表述一段范围的 slices。mi_slice_t 是 slice 的元数据，并不表示所在的 slice 内存区域，所有的 mi_slice_t 元素放在 segment 开头的 slices 内存中，_mi_segment_page_start_from_slice 函数可以得到 slice 的实际内存开头地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">mi_page_t</span>  <span class="n">mi_slice_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// A &#34;span&#34; is is an available range of slices. The span queues keep
</span></span></span><span class="line"><span class="cl"><span class="c1">// track of slice spans of at most the given `slice_count` (but more than the previous size class).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">mi_span_queue_s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_slice_t</span><span class="o">*</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_slice_t</span><span class="o">*</span> <span class="n">last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// span 最多包含的 slice 个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span>      <span class="n">slice_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">mi_span_queue_t</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="commitdecommit">Commit/Decommit</h1>
<p>在 segment 中，每 MI_COMMIT_SIZE area 有一个 bit（mask） 标记该区域是 commited 还是 decommited。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// 最小的 commit 大小，用于 commit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MI_MINIMAL_COMMIT_SIZE      (16*MI_SEGMENT_SLICE_SIZE)           </span><span class="c1">// 1MiB
</span></span></span><span class="line"><span class="cl"><span class="c1">// commit 的最小单位，必须是 slice 的整数倍，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 值越大，commit 和 decommit 的效率越高，但精度越小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MI_COMMIT_SIZE              (MI_SEGMENT_SLICE_SIZE)              </span><span class="c1">// 64KiB
</span></span></span><span class="line"><span class="cl"><span class="c1">// commit area bit 位个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MI_COMMIT_MASK_BITS         (MI_SEGMENT_SIZE / MI_COMMIT_SIZE) 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 当前系统，一个 size_t 的比特个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MI_COMMIT_MASK_FIELD_BITS    MI_SIZE_BITS
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 需要 size_t 类型的 mask 数组的大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MI_COMMIT_MASK_FIELD_COUNT  (MI_COMMIT_MASK_BITS / MI_COMMIT_MASK_FIELD_BITS)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">mi_commit_mask_s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">mask</span><span class="p">[</span><span class="n">MI_COMMIT_MASK_FIELD_COUNT</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">mi_commit_mask_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">mi_segment_s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 是否允许 decommit, mi_option_decommit_delay option 可以设置是否允许 delay decommit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span>              <span class="n">allow_decommit</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">  <span class="c1">// delay decommit 的过期时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_msecs_t</span>        <span class="n">decommit_expire</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 需要 delay decommit 的 mask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_commit_mask_t</span>  <span class="n">decommit_mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// commit 状态 bit mask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_commit_mask_t</span>  <span class="n">commit_mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>commit 时，要求最小的大小是 MI_MINIMAL_COMMIT_SIZE，而 decommit 时，只要求 MI_COMMIT_SIZE，分别对应 Liberal 和 Conservative 两种在 mimalloc 中使用的术语。</p>
<h2 id="segment-commit">Segment Commit</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">bool</span> <span class="nf">mi_segment_commitx</span><span class="p">(</span><span class="n">mi_segment_t</span><span class="o">*</span> <span class="n">segment</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">commit</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">mi_stats_t</span><span class="o">*</span> <span class="n">stats</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 确保需要delay decommit 的之前都是 commited 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_assert_internal</span><span class="p">(</span><span class="n">mi_commit_mask_all_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">commit_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">decommit_mask</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// commit liberal, but decommit conservative
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span>   <span class="n">full_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_commit_mask_t</span> <span class="n">mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 计算得到需要更新的 mask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_segment_commit_mask</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="o">!</span><span class="n">commit</span><span class="cm">/*conservative*/</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">full_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">mi_commit_mask_is_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">)</span> <span class="o">||</span> <span class="n">full_size</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 判断是 commit &amp;&amp; 需要更新 mask
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">commit</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mi_commit_mask_all_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">commit_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_zero</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mi_commit_mask_t</span> <span class="n">cmask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mi_commit_mask_create_intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">commit_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_mi_stat_decrease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_mi_stats_main</span><span class="p">.</span><span class="n">committed</span><span class="p">,</span> <span class="n">_mi_commit_mask_committed_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmask</span><span class="p">,</span> <span class="n">MI_SEGMENT_SIZE</span><span class="p">));</span> <span class="c1">// adjust for overlap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_mi_os_commit</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">full_size</span><span class="p">,</span><span class="o">&amp;</span><span class="n">is_zero</span><span class="p">,</span><span class="n">stats</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="n">mi_commit_mask_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">commit_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>     
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 判断是 decommit &amp;&amp; 有 bit 还是 commited 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">commit</span> <span class="o">&amp;&amp;</span> <span class="n">mi_commit_mask_any_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">commit_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mi_assert_internal</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">start</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">segment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//mi_assert_internal(mi_commit_mask_all_set(&amp;segment-&gt;commit_mask, &amp;mask));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">mi_commit_mask_t</span> <span class="n">cmask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mi_commit_mask_create_intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">commit_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_mi_stat_increase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_mi_stats_main</span><span class="p">.</span><span class="n">committed</span><span class="p">,</span> <span class="n">full_size</span> <span class="o">-</span> <span class="n">_mi_commit_mask_committed_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmask</span><span class="p">,</span> <span class="n">MI_SEGMENT_SIZE</span><span class="p">));</span> <span class="c1">// adjust for overlap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">allow_decommit</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="n">_mi_os_decommit</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">full_size</span><span class="p">,</span> <span class="n">stats</span><span class="p">);</span> <span class="c1">// ok if this fails
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 清除 commit 状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mi_commit_mask_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">commit_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// decommit_mask 中，属于 mask 的部分已经得标记为 decommit 的了，但剩下部分还需要 delay decommit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// increase expiration of reusing part of the delayed decommit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">commit</span> <span class="o">&amp;&amp;</span> <span class="n">mi_commit_mask_any_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">decommit_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">segment</span><span class="o">-&gt;</span><span class="n">decommit_expire</span> <span class="o">=</span> <span class="n">_mi_clock_now</span><span class="p">()</span> <span class="o">+</span> <span class="n">mi_option_get</span><span class="p">(</span><span class="n">mi_option_decommit_delay</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// always undo delayed decommits
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_commit_mask_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">decommit_mask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="os-commit">OS Commit</h2>
<p>OS 的 commit/decommit 要求是 page 对齐的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// 将 addr 安排 page 对齐后，得到新的地址和大小
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果是 conservative, 只得到在 (addr, addr+size) 内部的 pages，
</span></span></span><span class="line"><span class="cl"><span class="c1">// 如果非 conservative，将得到（addr， addr+size）横跨的所有 pages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">mi_os_page_align_areax</span><span class="p">(</span><span class="kt">bool</span> <span class="n">conservative</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">size_t</span><span class="o">*</span> <span class="n">newsize</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// page align conservatively within the range
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span><span class="o">*</span> <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">conservative</span> <span class="o">?</span> <span class="n">mi_align_up_ptr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">_mi_os_page_size</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">mi_align_down_ptr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">_mi_os_page_size</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">conservative</span> <span class="o">?</span> <span class="n">mi_align_down_ptr</span><span class="p">((</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">_mi_os_page_size</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">mi_align_up_ptr</span><span class="p">((</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">addr</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">_mi_os_page_size</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">  <span class="n">ptrdiff_t</span> <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">end</span> <span class="o">-</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mi_assert_internal</span><span class="p">((</span><span class="n">conservative</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span><span class="n">diff</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">conservative</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span><span class="n">diff</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">newsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span><span class="n">diff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Commit/Decommit memory.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Usually commit is aligned liberal, while decommit is aligned conservative.
</span></span></span><span class="line"><span class="cl"><span class="c1">// (but not for the reset version where we want commit to be conservative as well)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">mi_os_commitx</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">commit</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">conservative</span><span class="p">,</span> <span class="kt">bool</span><span class="o">*</span> <span class="n">is_zero</span><span class="p">,</span> <span class="n">mi_stats_t</span><span class="o">*</span> <span class="n">stats</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">csize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 得到 page 对齐后的地址和大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">start</span> <span class="o">=</span> <span class="n">mi_os_page_align_areax</span><span class="p">(</span><span class="n">conservative</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">csize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// commit 将内存标记为可读写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 由于内存已经在 segment 中分配了，所以 commit 只是改变访问权限，真正的内存分配都是预先分配好的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">commit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// commit: ensure we can access the area
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">err</span> <span class="o">=</span> <span class="n">mprotect</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">csize</span><span class="p">,</span> <span class="p">(</span><span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">err</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cp">#if defined(MADV_DONTNEED) &amp;&amp; MI_DEBUG == 0 &amp;&amp; MI_SECURE == 0
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      <span class="c1">// 告诉操作系统，page 可以被回收了，同时减少进程的 memory 占用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// decommit: use MADV_DONTNEED as it decreases rss immediately (unlike MADV_FREE)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// (on the other hand, MADV_FREE would be good enough.. it is just not reflected in the stats :-( )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">err</span> <span class="o">=</span> <span class="n">madvise</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">csize</span><span class="p">,</span> <span class="n">MADV_DONTNEED</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>      <span class="c1">// PROT_NONE 可以用来做 memory guard，用来检测 overflow，或者其他非法访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// decommit: just disable access (also used in debug and secure mode to trap on illegal access)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">err</span> <span class="o">=</span> <span class="n">mprotect</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">csize</span><span class="p">,</span> <span class="n">PROT_NONE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">err</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="初始化与退出">初始化与退出</h1>
<p>Mimalloc 的使用方式可以是动态/静态链接后，使用 mi_malloc，也可以通过动态/静态链接的方式，override malloc 和 new。不管是哪种方式，mimalloc 自己的数据结构，以及和线程/进程相关的行为动作都需要被初始化。</p>
<h2 id="初始化析构时机">初始化/析构时机</h2>
<p>当进程被加载到进入main 函数前，mimalloc 需要完成主线程元数据初始化，其他线程的元数据则随着线程创建后的第一次使用时完成初始化。被 <strong>attribute</strong>((constructor)) 标记的函数，会在 main 函数执行之前被自动的执行，mimalloc 利用这个时机进行初始化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// GCC,Clang: use the constructor attribute
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span> <span class="n">_mi_process_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mi_process_load</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>pthread_key_create 创建一个 thread-specific 的 key， 当线程终止时，如果destructor 不为 null且 key 关联的 value 不为 null 时，destructor 函数将被调用，key 关联的 value 作为函数参数。pthread_setspecific 可以设置 key 关联的 value。</p>
<p>Mimalloc 利用 pthread_key_create 注册线程终止时的析构函数 mi_pthread_done，参数为线程的 heap。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// 线程终止时，如果 key 关联的值不为 NULL, destructor 函数被执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">pthread_key_create</span><span class="p">(</span><span class="n">pthread_key_t</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// fn mi_process_setup_auto_thread_done
</span></span></span><span class="line"><span class="cl"><span class="c1">// _mi_heap_default_key 为全局定义的变量，对所有线程可见
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pthread_key_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_mi_heap_default_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mi_pthread_done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// fn _mi_heap_set_default_direct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">_mi_heap_default_key</span> <span class="o">!=</span> <span class="p">(</span><span class="n">pthread_key_t</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// can happen during recursive invocation on freeBSD
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// heap 为线程的 heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pthread_setspecific</span><span class="p">(</span><span class="n">_mi_heap_default_key</span><span class="p">,</span> <span class="n">heap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 atexit 注册进程终止时的执行函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// fn mi_process_load
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">atexit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mi_process_done</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="heap-初始化">Heap 初始化</h2>
<p>每个线程有自己的 heaps，_mi_heap_default 是一个 thread-local 指针指向默认 heap。mi_thread_data_t 对所有 thread-local 的数据进行管理，每个线程的默认堆作为第一个字段，通过 _mi_heap_default 便能够找到 mi_thread_data_t。</p>
<p>非主线程的 mi_thread_data_t 是在线程被初始化时动态分配在堆上的，自身的内存由系统 malloc 分配，而且有个小型的缓存 cache，以避免线程频繁创建终止引入的频繁内存分配。初始化时机为第一次进行内存分配，对默认堆进行初始化时，调用 mi_thread_init 时进行内存分配和初始化。</p>
<p>主线程的 tld_main，_mi_heap_main  是两个全局变量，在执行初始化流程之前已经被初始化，所以只需要简单的执行一些数据的初始化。不同于其他线程使用 mi_thread_data_t 结构进行封装，主线程并没有使用这个结构，其他线程使用 mi_thread_data_t 的目的是一次就能完成内存分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// 线程局部变量，一个指针大小，以空堆初始化，确保指针不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mi_decl_thread</span> <span class="n">mi_heap_t</span><span class="o">*</span> <span class="n">_mi_heap_default</span> <span class="o">=</span> <span class="p">(</span><span class="n">mi_heap_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_mi_heap_empty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 线程创建时动态分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">mi_thread_data_s</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 线程默认堆，通过 heap 能引用到 tld
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_heap_t</span>  <span class="n">heap</span><span class="p">;</span>  <span class="c1">// must come first due to cast in `_mi_heap_done`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 线程所有的 local data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_tld_t</span>   <span class="n">tld</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">mi_thread_data_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define TD_CACHE_SIZE (8)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 小型的 mi_thread_data_t 缓存，默认 8 个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="nf">_Atomic</span><span class="p">(</span><span class="n">mi_thread_data_t</span><span class="o">*</span><span class="p">)</span> <span class="n">td_cache</span><span class="p">[</span><span class="n">TD_CACHE_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 用于分配 mi_thread_data_t，先从 cache 中寻找，没有从系统分配
</span></span></span><span class="line"><span class="cl"><span class="c1">// mi_thread_data_alloc 的实现是无锁的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="n">mi_thread_data_t</span><span class="o">*</span> <span class="nf">mi_thread_data_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// fn _mi_heap_set_default_direct
</span></span></span><span class="line"><span class="cl"><span class="c1">// 初始化完成后，_mi_heap_default 指向分配的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">_mi_heap_default</span> <span class="o">=</span> <span class="n">heap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 主线程 thread local data, 全局静态变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="n">mi_tld_t</span> <span class="n">tld_main</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 主线程默认堆，全局变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mi_heap_t</span> <span class="n">_mi_heap_main</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="动态库-unload">动态库 unload</h2>
<p>在 linux 下，所有动态库共享主进程的一个堆，但在 windows 下，不同 dll 有自己的堆，而且在动态库被 unload 时，会各自调用 atexit 函数。当独立的进程退出时，所有从系统分配的资源都会被系统回收。但是当 mimalloc 被静态链接到其他动态库，而动态库被不断地 loaded/unloaded 时，如果不在 atexit 时进行内存清理，会导致之前分配的内存没有及时释放。mimalloc  的做法是，只有 mimalloc 是被静态链接时，在 atexit 时，都执行内存回收，虽然在 linux 下没有必要。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// fn mi_process_done
</span></span></span><span class="line"><span class="cl"><span class="c1">// cmakelist.txt 中的选项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#ifndef MI_SKIP_COLLECT_ON_EXIT
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="cp">#if (MI_DEBUG != 0) || !defined(MI_SHARED_LIB)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="c1">// free all memory if possible on process exit. This is not needed for a stand-alone process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// but should be done if mimalloc is statically linked into another shared library which
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// is repeatedly loaded/unloaded, see issue #281.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mi_collect</span><span class="p">(</span><span class="nb">true</span> <span class="cm">/* force */</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="参考资料">参考资料</h1>
<p>Mimalloc paper:  <a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/06/mimalloc-tr-v1.pdf">https://www.microsoft.com/en-us/research/uploads/prod/2019/06/mimalloc-tr-v1.pdf</a></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">bilosikia</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2023-02-25
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        
        <a class="next" href="/post/rust/rust-pin-project/">
            <span class="next-text nav-default">rust Pin Project</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://bilosikia.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>bilosikia</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
